1 глава
Держим оборону
1. На пути к хорошему коду
Есть огромная разница между кодом, который на первый взгляд работа%
ет, правильным кодом и хорошим кодом. М. Э. Джексон (M. A. Jackson)
писал: «Всякий мудрый программист должен понимать, что есть раз%
ница между тем, чтобы заставить программу работать, и тем, чтобы за%
ставить ее делать это правильно». (Jackson 75) И вот в чем эта разница:
• Легко написать код, который почти всегда работает. Вводишь
в программу обычные данные и получаешь обычные результаты.
Но стоит подать на вход нечто необычное, и все может рухнуть.
• Правильный код не рухнет. Для любого набора входных данных ре%
зультат будет корректен. Однако обычно количество всевозможных
комбинаций входных данных оказывается невероятно большим,
и все их трудно протестировать.
• Однако не всякий правильный код оказывается хорошим – напри%
мер, его логику трудно проследить, код непонятен, его практически
невозможно сопровождать.
2. Готовьтесь к худшему
Предположения служат причиной появления кода с ошибками. Очень
легко предположить следующее:
• Функцию никогда не станут вызывать таким способом. Ей всегда
будут передаваться только допустимые параметры.
• Этот фрагмент кода всегда будет работать, он никогда не сгенериру%
ет ошибку.
• Никто не станет пытаться обратиться к этой переменной, если
я напишу в документации, что она предназначена только для
внутреннего употребления.
3. Что такое защитное программирование
Как следует из названия, защитное программирование – это тщатель%
ное, осторожное программирование. Чтобы построить надежную про%
грамму, мы должны спроектировать каждую компоненту системы так,
чтобы она была как можно лучше защищена. Мы расправимся с непи%
саными допущениями, сделав для них явные проверки в коде. Таким
способом мы попытаемся предотвратить или хотя бы обнаружить такое
обращение к нашему коду, которое вызывает некорректное поведение.
Защитное программирование позволяет обнаружить мелкие проблемы
на ранней стадии, не дожидаясь момента, когда они приведут к серьез%
ным катастрофам. Сплошь и рядом можно столкнуться с тем, как
«профессиональные» разработчики спешат написать код, не дав себе
труда задуматься.
4. Этот страшный, ужасный мир
Защитное программирование повышает безопасность программ, пред%
охраняя от такого рода умышленного злоупотребления. Взломщики и
создатели вирусов не упускают случая воспользоваться неаккуратно
написанным кодом, чтобы получить контроль над приложением и реа%
лизовать свои зловредные планы. Это серьезная угроза в современном
мире программных разработок, которая приводит к огромному ущер%
бу, наносимому продуктивности, финансам и конфиденциальности.
5. Технологии защитного программирования
Защитное программирование предполагает соблюдение ряда разум%
ных правил. Обычно, когда заходит речь о защитном программирова%
нии, людям приходит в голову использовать операторы контроля,
и это правильно. Мы поговорим о них позже. Но существует также мас%
са простых приемов программирования, которые неизмеримо повысят
надежность вашего кода.
6. Выберите хороший стиль кодирования 
и пользуйтесь крепкой архитектурой
Значительной части ошибок можно избежать, придерживаясь доброт%
ного стиля кодирования. Это правило согласуется с остальными глава%
ми данной части. Такие простые вещи, как выбор осмысленных имен
переменных и разумная расстановка скобок, делают код понятнее
и уменьшают шансы пропустить ошибку.
7. Пишите код без спешки
Сплошь и рядом программы пишут сломя голову. Программист быстренько ляпает функцию, пропускает ее через компилятор для проверки синтаксиса, запускает, чтобы убедиться в ее работоспособности,
и переходит к очередной задаче. Такой подход чреват опасными по%
следствиями.
8. Не верьте никому
• Обычный пользователь случайно введет в программу неверные
данные или воспользуется ею некорректно.
• Злоумышленник сознательно попытается заставить программу ве%
сти себя некорректно.
• Клиентский код вызовет вашу функцию, неправильно передав ей
параметры или задав им недопустимые значения.
• Операционная среда не сможет предоставить программе необходи%
мый сервер.
• Внешние библиотеки окажутся некорректными и не выполнят те
контракты по интерфейсам, на которые вы полагались.
9. Стремитесь к ясности, а не к краткости
Когда встает выбор между кратким (но непонятным) и ясным (но скуч%
ным) кодом, делайте его в пользу того кода, смысл которого понятен,
даже если он менее элегантен. Например, сложные арифметические
выражения разбивайте на последовательность отдельных операторов,
логика которых понятнее.
10. Не позволяйте никому лезть туда, где ему нечего делать
• В объектно%ориентированных языках доступ к внутренним данным
класса запрещается путем объявления его закрытым. В C++ можно
воспользоваться идиомой Чеширского кота (или pimpl) – стандарт%
ным приемом, употребляемым для выведения внутренней структу%
ры класса из его открытого файла заголовка. (Meyers 97) 
• В процедурных языках также можно воспользоваться идеями объ%
ектно%ориентированной упаковки, заключив закрытые данные внут%
ри непрозрачных типов и обеспечив корректные операции над ними. 
• Дайте всем переменным минимально необходимую область видимо%
сти; не делайте их глобальными, если в этом нет необходимости. Ес%
ли их можно сделать локальными для функции, не объявляйте их
на уровне файла. Если их можно сделать локальными для цикла, не
объявляйте их на уровне функции.
11. Включайте вывод всех предупреждений при компиляции
Если ваш код изобилует опасными конструкциями, такие предупреж%
дения могут занять многие страницы. К сожалению, по этой причине
очень часто отключают вывод предупреждений компилятором или
просто не обращают на них внимания. Так поступать не следует.
Всегда включайте вывод предупреждений компилятором, и если ваш
код генерирует предупреждения, немедленно исправьте его, чтобы та%
ких сообщений больше не было. Нельзя успокаиваться, пока компиля%
ция не станет проходить гладко при включенном выводе предупрежде%
ний. Они существуют не зря. Даже когда вам кажется, что какое%то
предупреждение несущественно, добейтесь его исчезновения, потому
что в один прекрасный день из%за него вы не заметите того предупреж%
дения, которое окажется действительно важным.
12. Пользуйтесь средствами статического анализа
Предупреждения компилятора представляют собой результат частич%
ного статического анализа кода – контроля кода, проводимого перед
запуском программы.
13. Применяйте безопасные структуры данных
Вероятно, самым распространенным видом уязвимостей в программах
является переполнение буфера. Оно возникает из%за небрежного при%
менения структур данных фиксированного размера. Если ваш код за%
писывает данные в буфер, не проверив предварительно его размер, то
возникает опасность записи за концом буфера.
14. Проверяйте все возвращаемые значения
Если функция возвращает значение, то делает это не зря. Проверяйте
возвращаемое значение. Если это код ошибки, нужно ее обработать.
Не допускайте появления в программе незамеченных ошибок; в итоге
поведение программы может стать непредсказуемым.
15. Аккуратно обращайтесь с памятью 
(и другими ценными ресурсами)
Будьте скрупулезны и освобождайте все ресурсы, которые захватывае%
те во время выполнения. Чаще всего имеется в виду оперативная па%
мять, но это не единственный ресурс. К другим видам ценных ресурсов,
которые нужно беречь, относятся файлы и блокировки потоков. Рас%
поряжайтесь своим добром экономно.
16. Инициализируйте все переменные там, где вы их объявили
Это проблема ясности. Смысл каждой переменной становится ясен, ес%
ли вы инициализируете ее. Опасно полагаться на эмпирические пра%
вила типа: «Раз я ее не инициализировал, значит, ее начальное значе#
ние мне неважно». Код со временем развивается. Отсутствие началь%
ного значения на каком%то этапе может превратиться в проблему.
17. Объявляйте переменные как можно позже
Благодаря этому переменная будет располагаться ближе к месту сво%
его использования и не станет мешаться в других частях кода. Кроме
того, понятнее станет код, в котором участвует эта переменная. Вам не
придется рыскать, выясняя тип и значение переменной: расположен%
ное рядом объявление сделает их очевидными.
18. Пользуйтесь стандартными средствами языка
C и C++ в этом отношении представляют собой кошмар. Их специфи%
кации существуют во многих вариантах, а поведение в наименее ясных
ситуациях не определено и оставлено на усмотрение конкретных реа%
лизаций. На сегодняшний день существует множество компиляторов,
обладающих тонкими различиями. В целом они совместимы между со%
бой, но оставляют вам достаточно возможностей свернуть себе шею.
19. Пользуйтесь хорошими средствами регистрации 
диагностических сообщений
Когда пишут новый код, то часто включают в него много операторов
вывода диагностики, чтобы разобраться в происходящем в программе.
Следует ли удалить их в конце работы? Сохранив их, вы облегчите
себе жизнь в будущем, если придется вернуться к этому коду, особен%
но если можно управлять выводом диагностики.
20. Выполняйте приведение типов с осторожностью
Большинство языков позволяет приводить (преобразовывать) данные
из одного типа в другой. Эта операция не всегда проходит успешно. Ес%
ли вы попытаетесь преобразовать 64%разрядное целое в меньший, 8%раз%
рядный тип, то что произойдет с 56 оставшимися битами? Среда вы%
полнения может неожиданно сгенерировать исключительную ситуа%
цию, а может исказить ваши данные, ничего при этом не сообщив.
Программисты часто не задумываются над такого рода вещами, а по%
тому их программы ведут себя неожиданным образом.
21. Подробности
Определяйте поведение по умолчанию
В большинстве языков есть оператор switch (переключатель), позво%
ляющий любую неожиданность обработать в группе default (по
умолчанию). Если попадание в default является ошибкой, явно от%
разите это в коде. Если ошибки нет, также отразите это в коде, и то%
гда сопровождающему код программисту станет все ясно.
Аналогично, если вы пишете оператор if без предложения else, за%
думайтесь, не следует ли обрабатывать логический случай по умол%
чанию.
Пользуйтесь идиомами языка
Следуя этому простому совету, вы гарантируете, что ваш код будет
понятен читающим его. Они реже будут ошибаться.
Проверяйте числовые результаты
Даже самые простые вычисления могут приводить к переполнению
или потере точности. Будьте настороже. Спецификации языков и ба%
зовые библиотеки предоставляют механизмы для определения до%
пустимых значений стандартных типов данных – воспользуйтесь
ими. Вы должны знать, какие числовые типы существуют и для ка%
ких целей их лучше применять.
Проверяйте допустимость каждого вычисления. Например, следи%
те за тем, чтобы ваши величины не приводили к делению на ноль.
Соблюдайте защищенность констант
Особенно это облегчает жизнь при программировании на C/C++. Ста%
райтесь объявлять как const все, что только можно. Этим достигают%
ся две цели: квалификаторы const способствуют документированию
кода и позволяют компилятору обнаруживать глупые ошибки. Он не
позволит вам изменить данные, модификация которых запрещена.
22. Ограничения
. Есть несколько вариантов реакции программы:
• Сделать вид, что ничего не случилось, и надеяться на лучшее.
• Оштрафовать на месте и разрешить дальнейшее движение (напри%
мер, напечатать диагностическое предупреждение или записать его
в журнал).
• Сразу арестовать; запретить двигаться дальше (например, прервать
выполнение программы контролируемым или неконтролируемым
образом).
Существует несколько разных сценариев использования ограничений:
Входные условия
Эти условия должны быть выполнены до входа в раздел кода. Если
входное условие не выполнено, это означает, что в коде клиента
есть ошибка.
Выходные условия
Эти условия должны быть выполнены после выхода из блока кода.
Если выходное условие не выполнено, это означает, что в коде по%
ставщика есть ошибка.
Инварианты
Эти условия должны быть выполнены при достижении в ходе вы%
полнения программы определенной точки, например между прохо%
дами цикла, при вызове методов и т. п. Невыполнение инварианта
означает, что в логике программы есть ошибка.
Операторы контроля
Это любое другое утверждение относительно состояния программы
в данный момент.
23. Какие ограничения налагать
Есть несколько проблем, которые можно решать с помощью ограниче%
ний. Например, можно делать следующее:
• Проверять, чтобы все обращения к массивам не выходили за их гра%
ницы.
• Контролировать неравенство нулю указателей перед их разымено%
ванием.
• Проверять допустимость параметров функций.
• Контролировать результаты функций, прежде чем их возвращать.
• Проверять состояние объекта перед операциями с ним.
• Защищать те участки кода, где должны быть комментарии. Они не
должны получать управление.
24. Снятие ограничений
Такого рода проверка ограничений обычно требуется только на этапах
разработки и отладки программы. После того как мы воспользовались
ограничениями, чтобы убедить себя (возможно, ошибочно) в правиль%
ности логики программы, следовало бы убрать их, чтобы готовая про%
грамма не делала лишней работы.
25. Резюме
Необходимо писать не просто корректный, но хороший код. Для этого
нужно документировать все сделанные предположения. В результате
код станет легче сопровождать и в нем окажется меньше места для
ошибок. Защитное программирование ориентировано на то, чтобы быть
готовым к худшему, что может случиться. Данная технология препят%
ствует превращению случайных огрехов в трудноуловимые ошибки.
2 глава
Тонкий расчет
1. Да в чем проблема?
Расположение и представление кода оказываются предметом разно%
гласий в большинстве современных языков программирования. Про%
извольное форматирование, позволяющее выразить свою художест%
венную индивидуальность, вошло в моду в начале 1960%х годов с появ%
лением Алгола: существовавшие к тому времени версии Fortran до%
пускали меньше свободы в формате. В последующем лишь очень
немногие языки отошли от такого подхода к свободе форматирования.
2. Знайте своих клиентов
Чтобы написать эффективный исходный код, необходимо понимать,
кто его будет читать. Если придется кого%то поставить в трудное поло%
жение, выясните, перед кем потом извиняться. В действительности,
есть три круга адресатов вашего кода:
Вы сами
У меня такой плохой почерк, что иногда мне самому трудно его ра%
зобрать. Это практически невозможно, если я не ставлю себе задачу
писать разборчиво. То же самое происходит и с кодом. Созданное ва%
ми должно быть понятно не только сразу после написания, но и по
прошествии лет. Кто мог подумать, что придется вернуться к (отно%
сительно) архаичному коду на COBOL, чтобы исправить в нем
ошибки, связанные с Y2K?
Компилятор
Компилятору все равно, как выглядит ваш код, – лишь бы в нем не
было синтаксических ошибок. Ему абсолютно безразлично, какую
задачу этот код решает. Можно подробно описать в комментариях,
что должна делать функция, но компилятор никогда не сообщит вам,
действительно ли она выполняет то, что сказано в комментариях.
Если код корректен, среда разработки будет вполне удовлетворена.
Прочие лица 
Это самая важная аудитория, интересы которой часто меньше всего
учитываются. 
Вам кажется, что хотя вы работаете в составе команды, никто нико%
гда не станет смотреть ваш код. Это ошибочное мнение.
Вы пишете какой%то код для себя дома. Стоит ли заботиться о его кра%
соте? Если «да», то в чем польза? В выработке качеств, которые дела%
ют вас профессионалом. У вас появляется прекрасная возможность
продемонстрировать настоящую дисциплину в проекте, когда никто
не оказывает на вас давления. Это возможность выработать хорошие
манеры. Если вы не справитесь с задачей в таких условиях, то неуди%
вительно, что у вас не хватит дисциплины в реальных проектах. 
3. Что такое хорошее представление?
Расположение кода должно передавать его смысл, а не скрывать.
Я предлагаю следующие критерии качества стиля представления кода.
Единообразие
Принципы отступов в коде должны быть одинаковы во всех частях
проекта. Не меняйте стиль в середине пути. Это не только выглядит
непрофессионально, но и может ввести в заблуждение, создавая
впечатление отсутствия связи между файлами с исходным кодом.
Отдельные правила представления должны быть внутренне непроти%
воречивыми. Расположение фигурных и квадратных скобок и т. п.
в различных ситуациях должно соответствовать единым правилам.
Количество пробелов в отступах должно быть всегда одинаковым.
Керниган и Ричи, основоположники C, подчеркивают важность
правильных отступов и затем говорят: «Положение скобок менее
важно, хотя люди склонны проявлять фанатизм в таких вопросах.
Мы выбрали один из нескольких популярных стилей. Выберите тот
стиль, который вам больше подходит, и точно ему следуйте». (Ker%
nighan Ritchie 88)
Стандартность
Разумно принять какой%нибудь из господствующих ныне стилей,
а не изобретать собственные правила отступа. Так будет проще для
тех, кто станет читать ваш код. И меньше шансов, что ваш стиль
вызовет у них отвращение.
Краткость
Можете ли вы кратко описать свою стратегию отступов? Подумайте
над этим. Если вы делаете нечто, пока не произойдет то#то и то#
то, а тогда вы будете делать это, если выполняется X; в противном
случае вы станете делать нечто другое в зависимости от…
Кому%то может потребоваться дополнить написанный вами код, и де%
лать это ему следует, придерживаясь того же стиля. Если его трудно
ухватить, можно ли считать такой стиль представления удачным?
4. Размещение скобок
Для иллюстрации влияния, которое представление оказывает на ис%
ходный код, и компромиссов, на которые приходится идти при выборе
стиля, разберем конкретный случай, связанный с важной проблемой
расположения кода C. Рассматривая варианты, возникающие в этой
одной простой области, мы продемонстрируем важность представле%
ния и степень его влияния на код.
5. Скобки в стиле K&R
Стиль K&R относится к старейшим, будучи предложенным основопо%
ложниками языка C, Керниганом и Ричи, в книге «Язык программи%
рования C» (Kernighan Ritchie 88). По этой причине его часто считают
исходным и лучшим. На него повлияла необходимость отобразить как
можно больше информации на маленьком экране. Пожалуй, это пре%
валирующий стиль для кода Java.
6. Расширенный стиль скобок
Более свободное расположение кода достигается в расширенном (ex#
dented) стиле, называемом также стилем Олмана. Лично мне он нра%
вится больше прочих.
7. Стиль Уайтсмита (с отступами)
Стиль с отступами менее распространен, хотя и встречается. Фигур%
ные скобки при этом имеют тот же отступ, что и код. Он получил на%
звание стиля Уайтсмита, поскольку применялся в примерах для
Whitesmiths C – раннего компилятора с языка С.
8. Другие стили скобок
Существуют и другие стили. Например, стиль GNU занимает промежу%
точное положение между расширенным стилем и стилем с отступами:
скобки располагаются посередине каждого уровня отступа. Есть и гиб%
ридные стили: стиль кода ядра Linux наполовину представляет K&R,
наполовину – стиль Олмана. Большинство программирующих на C#
тоже комбинирует стили расположения.
9. Единственно верный стиль
Поняв, что такое правильный стиль кодирования, на что он влияет
и почему необходим, нужно выбрать для себя что%то подходящее. Вот
тут и начинается столкновение. Последовательности одного религиоз%
ного течения в представлении ведут борьбу с проповедниками другого,
порождая гражданские войны между программистами. Но настоящий
мастер не ввязывается в эти мелкие дрязги, предпочитая взвешенный
подход.
10. Внутрифирменные стили 
(и когда их придерживаться)
Важность и полезность внутрифирменных стилей обусловлена рядом
причин. Когда все танцуют под одну дудку, исходный код оказывается
полностью единообразным и однородным. Что в этом хорошего? Улуч%
шается качество кода и растет надежность разработки программного
обеспечения. И вот почему:
• Любой код, выходящий за пределы организации, имеет аккуратное
представление и согласованность, создавая впечатление хорошей
продуманности. Наличие в одном проекте разнородных стилей соз%
дает впечатление неряшливости и непрофессионализма.
• Компания может быть уверена в том, что программы пишутся со%
гласно единому стандарту, включающему в себя определенные
идиомы и методологии. Это не гарантирует получение хорошего ко%
да, но дает некоторую защиту от появления плохого кода.
• Компенсируются недостатки инструментария: по разному настро%
енные IDE будут вступать в конфликт между собой, разрывая код
на части и досаждая форматированием. Стандарт создает ровную
почву (и общего врага для всех программистов).
• Привлекательна возможность сразу оценить состояние кода, напи%
санного коллегами, и быстро сделать необходимые изменения при
сопровождении. Меньше времени тратится на чтение, а значит, бе%
регутся финансовые ресурсы компании.
• Поскольку программисты перестанут непрерывно заново формати%
ровать код в соответствии со своими эстетическими пристрастия%
ми, система управления версиями станет намного эффективнее. Ес%
ли один программист будет переформатировать код второго, чтобы
привести его к «своему» стилю, это отразится на работе утилит,
сравнивающих версии. Многие из них действуют довольно грубо
и покажут массу несущественных различий в расстановке пробель%
ных символов и скобок.
11. Установка стандарта
Сложность задачи зависит от особенностей членов вашего коллектива:
• Сколько всего программистов
• Как каждый в отдельности пишет код
• Насколько схожи между собой их стили программирования
• Заинтересованы ли они в наличии стандарта
• Готовы ли они к тому, чтобы изменить свой стиль
12. Религиозные войны?
Вести религиозные войны по поводу форматирования кода – пустая
трата времени; есть гораздо более важные проблемы, заслуживающие
вашего внимания. Но будьте осторожны: формат кода – не единствен%
ное больное место у программистов. Помимо него существуют выбор
редактора, компилятора, методологии, Настоящего языка1 и т. д.
13. Резюме
Представление – одна из главных характеристик, отличающих хоро%
ший код от плохого. Программист может многое узнать по внешнему
виду кода, поэтому стоит позаботиться о его надлежащем форматиро%
вании. Важно уметь толково расположить код в соответствии с прави%
лами существующего в фирме стандарта кодирования, обеспечив его
максимальную понятность.
3 глава
Что в имени тебе моем?
1. Зачем нужны хорошие имена?
Нужно тщательно выбирать имена для своих объектов. Ведь исходный
код должен быть понятен. Имя создает путь к пониманию, контролю
и овладению. Если правильно выбрать имя, по нему можно понять на#
значение объекта. 
2. Каким объектам мы даем имена?
Задумаемся как программисты над тем, каким объектам мы даем име%
на и какие имена мы им даем. Сначала о том, какие конструкции ча%
ще всего получают от нас имена, когда мы пишем код:
• Переменные
• Функции
• Типы (классы, перечисления, структуры, определения типов)
• Имена пространств C++ и пакетов Java
• Макросы
• Файлы с исходным текстом
3. Игра в названия
Какое назначить имя? Техника создания любого имени зависит от
стандарта кодирования, которого вы придерживаетесь. Однако хотя
стандарт и определяет некоторые правила составления имен, он не бы%
вает настолько конкретным, чтобы определить правильное имя любо%
го элемента, входящего в программу. 
4. Технические подробности
В следующих разделах обсуждается, как выбирать имена в каждой из
перечисленных категорий объектов. Даже если у вас многолетний опыт
программирования, обзор существующих принципов формирования
имен может оказаться полезен и для вас.
5. Роза пахнет розой
Значение имени больше, чем может показаться на первый взгляд, и су%
ществует масса соображений при выборе имени для программного объ%
екта. Какими главными принципами следует руководствоваться? 
Чтобы выбрать хорошее имя, нужно:
• Соблюдать единообразие
• Связывать имя с содержимым
• Извлекать из имен практическую пользу
6. Резюме
Наши предки знали в те времена то, что хорошие программисты знают
сейчас: очень важно правильно выбрать имя. Хорошие имена не про%
сто удовлетворяют эстетическую потребность – они передают инфор%
мацию о структуре кода. Они служат важным средством, позволяю%
щим облегчить понимание и сопровождение кода. 
4 глава
Литературоведение 
1. Самодокументируемый код
Гордиться тут, собственно, нечем. Сложная и имеющая практическую
ценность программа требует большого мастерства. Практика показы%
вает, что читать компьютерные программы гораздо сложнее, чем пи%
сать их. Всякий, кто знаком с Perl, это подтвердит: данный язык пред%
ставлялся как предельный случай «напиши и забудь». И вправду, ста%
рый код Perl может казаться совершенно непостижимым. Однако не%
понятный код можно написать на любом языке, и особых стараний
для этого не требуется.
2. Техника написания самодокументируемого кода
Обычно считается, что самодокументируемый код должен содержать
в себе обилие комментариев. Хорошие комментарии, несомненно, нуж%
ны, но ими дело не ограничивается. На самом деле нужно стремиться
избегать комментариев путем написания такого кода, в котором в них
нет необходимости.
3. Практические методологии 
самодокументирования
В завершение этой главы мы сравним два конкретных метода докумен%
тирования кода. Помните, что эти методы менее предпочтительны, чем
те, которые мы уже рассмотрели. Как сказано у Кернигана и Плоэра,
«нужно не документировать плохой код, а переписать его заново».
4. Резюме 
Мы пишем код для того, чтобы передать информацию. Код без доку%
ментации опасен и малоинформативен. Его трудно сопровождать.
Плохая документация также создает проблемы: она либо вводит чита%
теля в заблуждение, либо делает программу ненадежной и требующей
дополнительных разъяснений.
5 глава
1. Что есть комментарий в коде?
Синтаксически комментарий представляет собой блок исходного тек%
ста, который игнорируется компилятором. Поместить в него можно
что угодно – хоть имена своих внуков, хоть цвет любимой рубашки;
компилятор и глазом не моргнет, встретив такое в файле.
2. Как выглядят комментарии?
Комментарии C помещаются в блоках между комбинациями /* и */
и могут занимать произвольное количество строк. В C++, C99, C#
и Java есть, кроме того, однострочные комментарии, следующие за //.
В других языках есть аналогичные средства комментирования блока#
ми и в строке, но синтаксис иной. 
3. Сколько комментариев требуется
Тех, кто изучает программирование, заставляют писать комментарии,
и в большом количестве. Но слишком обширные комментарии могут
быть недостатком – важные фрагменты кода оказываются затерянны%
ми среди потока слов. Когда вам приходится продираться через про%
странные комментарии, вместо того чтобы читать сам код, качество
последнего снижается. 
4. Что помещать в комментарии? 
Лучше совсем без комментариев, чем плохие комментарии – они дез%
информируют читателя и вводят его в заблуждение. Что же следует
помещать в комментарии? Вот несколько основных советов, как повы%
сить качество комментариев.
5. На практике
Проиллюстрируем принципы комментирования следующим приме%
ром. Рассмотрим фрагмент кода C++. Даже если не критиковать идио%
матическую сторону, код не вполне понятен.
6. Замечание об эстетичности
Несомненно, вам приходилось сталкиваться с горячими обсуждения%
ми того, как нужно форматировать комментарии. Я не намерен на%
ставлять вас на путь истинный в этом вопросе (его просто не существу%
ет), но есть ряд важных аспектов, которые нужно учитывать. Отнеси%
тесь к ним как к общим принципам, сообразуясь с вашими личными
вкусами, а не как к безусловным требованиям. 
7. Работа с комментариями 
Комментариями удобно пользоваться при написании кода. Но не зло%
употребляйте ими.
8. Резюме
Мы пишем много комментариев. Это вызвано тем, что мы пишем мно%
го кода. Важно научиться писать правильные комментарии, иначе
наш код может потонуть под грузом бестолковых или устаревших
комментариев. 
Не нужно переоценивать значение комментариев; благодаря хорошим
комментариям плохой код лучше не станет. Целью должно быть напи%
сание самодокументируемого кода, для которого не требуются ника%
кие комментарии.
6 глава
Людям свойственно ошибаться
1. Откуда что берется
Ошибки были и будут. Неприятные результаты могут быть следствием
почти любой операции. Это не то же самое, что дефект программы, по%
скольку вы заранее знаете, что может произойти ошибка. Например,
вам нужно открыть файл базы данных, а он оказывается удален, или
диск переполнен, и операция записи становится невозможной, или не%
доступен требуемый веб%сервис. 
Ошибки пользователя
Глупый юзер варварски обращается с вашей любимой программой.
Возможно, он ввел неверные данные или попытался выполнить со%
вершенно бессмысленную операцию. Хорошая программа укажет
на ошибку и поможет пользователю исправить ее. Она не станет из%
деваться над ним или жаловаться непонятно на что. 
Ошибка программиста
Пользователь действовал правильно, но код некорректен. Где%то
есть дефект, недосмотр программиста, с которым пользователь ни%
чего не может сделать (кроме как постараться избегать в будущем).
В идеале таких ошибок быть не должно. 
Здесь возникает замкнутый круг: необрабатываемые аварийные си%
туации приводят к ошибкам в программе. А эти ошибки могут при%
водить к возникновению аварийных ситуаций в других местах ко%
да. Поэтому мы считаем защитное программирование важной тех%
нологией.
Исключительные обстоятельства
Пользователь действовал правильно, и программист ничего не напу%
тал. Вмешалась неверная судьба, и мы столкнулись с чем%то, чего
нельзя было избежать. Разорвалось сетевое соединение, кончились
чернила в принтере или не осталось места на диске.
2. Механизмы сообщения об ошибках
Есть несколько стандартных стратегий передачи информации об ошиб%
ке в клиентский код. Вы можете встретить код, в котором применяется
любая из них, поэтому каждый из имеющихся диалектов должен быть
вам понятен. Обратите внимание на особенности этих методов сообще%
ния об ошибках и на преимущества тех или иных из них в отдельных
ситуациях.
3. Обнаружение ошибок
Возвращаемые значения
Успешно ли выполнилась функция, определяется по возвращаемо%
му ею значению. Эта проверка на отказ тесно связана с самим вызо%
вом функции; подразумевается, что, выполняя его, вы проверяете,
был ли он успешным. Учитывать полученный результат или нет –
дело ваше.
Переменные состояния ошибки
После вызова функции нужно рассмотреть значение переменной со%
стояния ошибки. Для переменной errno в модели C нет необходимо%
сти проверять наличие ошибки после каждого обращения к функ%
ции. Сбросьте значение errno, а затем последовательно вызовите
любое число стандартных библиотечных функций. После этого по%
смотрите на значение errno. Если оно соответствует коду ошибки,
значит, одна из вызывавшихся функций дала сбой. Вы не узнаете,
какая именно, но иногда можно воспользоваться и таким упрощен%
ным способом обнаружения ошибок. 
Исключительные ситуации
Если одна из подчиненных функций сгенерировала исключитель%
ную ситуацию, вы можете либо перехватить ее, либо игнорировать
и позволить ей подняться на более высокий уровень. Обоснованное
решение можно принять лишь тогда, когда известно, какие исклю%
чительные ситуации могут генерироваться. Такое знание может
дать вам документация (если она заслуживает доверия).
В Java исключительные ситуации реализованы так, что эта доку%
ментация находится в самом коде. Программист обязан написать
для каждого метода спецификацию исключений, указав, какие ис%
ключительные ситуации могут генерироваться. Java – единствен%
ный из основных языков программирования, который предъявляет
такие требования. Исключение, отсутствующее в списке, не сможет
проскочить, потому что компилятор осуществляет статическую про%
верку с целью не допустить этого.1
Сигналы
Есть лишь один способ обнаружить сигнал: установить для него об%
работчик. Делать это необязательно. Можно не устанавливать ника%
ких обработчиков сигналов и сохранить поведение по умолчанию.
4. Обработка ошибок
Где она возникла
Это совсем не то место, где она станет обрабатываться. Где находит%
ся источник – в базовой системной компоненте или периферийном
модуле? Эти данные могут присутствовать в сообщении об ошибке
либо быть получены вручную. 
Что вы пытались сделать?
Что спровоцировало ошибку? В этом может быть ключ ко всем вос%
становительным действиям. В отчете об ошибке такие сведения
встречаются редко, но по контексту можно выяснить, какая функ%
ция была вызвана. 
Почему возник сбой
В чем суть проблемы? Нужно точно узнать, что случилось, а не про%
сто установить класс ошибки. Какая часть приведшей к ошибке
операции успела выполниться? Прекрасно, если выполнилось все
или ничего, но обычно программа оказывается в некоем промежу%
точном состоянии.
Когда это случилось
Это локализация ошибки по времени. Произошел ли отказ только
что или это проблема двухчасовой давности, известившая о себе
только сейчас? 
Степень тяжести ошибки
Одни проблемы опаснее других, хотя при обнаружении они все рав%
нозначны – не разобравшись с проблемой и не найдя ее решения,
нельзя двигаться дальше. Степень тяжести обычно определяет вы%
звавший уровень исходя из того, насколько легко возобновить рабо%
ту или найти обходной путь.
Как исправить ошибку
Решение может быть очевидным (например, вставить дискету и по%
вторить операцию) или не совсем (например, потребуется модифи%
цировать параметры функции, сделав их совместимыми). Чаще все%
го вывод делается на основании других источников информации.
5. Подымаем скандал
Мы уже довольно долго занимаемся ошибками, которыми нас снабжа%
ют другие. Пора поменяться местами и самим выступить в роли нехо%
роших мальчиков: будем генерировать ошибки. Если вы пишете функ%
цию, в ней могут происходить неправильные вещи, о которых нужно
сообщать вызывающему. И делать это необходимо – не проходите мимо
сбоев. Даже если вы уверены, что вызвавший не будет знать, что делать
с проблемой, вы должны проинформировать его. Не пишите лживый
код, который якобы делает то, чего на самом деле он не выполняет.
6. Управление ошибками
Стандартный принцип для генерации и обработки ошибок требует нали%
чия единообразной стратегии обработки сбоев, в каком бы месте они ни
проявились. Вот общие административные соображения, относящие%
ся к возникновению, обнаружению и обработке программных ошибок:
• Избегайте ситуаций, чреватых ошибками. Лучше напишите код,
который гарантированно будет работать. Например, чтобы не воз%
никало ошибок выделения памяти, заранее позаботьтесь о резерви%
ровании достаточных ресурсов. Когда у вас обеспечен пул памяти,
программа не может испытывать недостатка в памяти. Конечно,это осуществимо, только если заранее известно, сколько нужно ре%
сурсов, но часто именно так и бывает.
• Определите возможное поведение вашей программы или функции
в необычных обстоятельствах. Исходя из этого установите, на%
сколько устойчивым должен быть код и насколько тщательной –
обработка ошибок. Не получится ли так, что функция, не привле%
кая внимания, сгенерирует скверные выходные данные согласно
классическому принципу GIGO?1
• Четко распределите между компонентами обязанности по обработ%
ке тех или иных ошибок. Объявите это в интерфейсе модуля. Пусть
ваш клиент знает, что будет работать всегда, а что может в один
прекрасный день отказать.
• Проконтролируйте свой стиль программирования: в какой момент
вы пишете код обработки ошибок? Не откладывайте его на буду%
щее; обязательно что%нибудь пропустите. Не откладывайте написа%
ние обработчиков до того времени, когда тестирование выявит про%
блемы – это не инженерный подход. 
• Если вы перехватили ошибку, что это – симптом или причина? Вы
можете обнаружить источник проблемы, которую нужно исправ%
лять тут же, или признак более застарелой проблемы. В последнем
случае не нужно писать много кода в этом месте; лучше поместить
его там, где он более уместен – в более раннем обработчике ошибки.
7. Резюме
Людям свойственно ошибаться (но у компьютеров это тоже хорошо по%
лучается). Исправление ошибок – святое дело.
На всякую написанную вами строчку кода должен приходиться надле%
жащий объем кода для доскональной проверки и обработки ошибок.
Программа без строгой обработки ошибок не может быть надежной.
В один прекрасный день случится какая%то неясная ошибка, и в ре%
зультате программа рухнет.
7 глава
Инструментарий программиста
1. Что такое инструмент программирования?
Для изготовления программного обеспечения мы пользуемся широ%
ким спектром инструментов – программ, которые строят программы,
если не слишком вдаваться в философию. Все, с помощью чего мы соз%
даем программное обеспечение, является в своем роде инструментом.
Одни инструменты помогают писать код. Другие помогают писать хо#
роший код. Третьи помогают привести в порядок тот запутанный код,
который вы только что написали.
2. А зачем они нужны – инструменты?
Невозможно создавать программы без базового набора программных
инструментов; вы не сдвинетесь с места без редактора и компилятора.
Есть ряд инструментов, без которых можно обойтись, но все же они
очень полезны. Чтобы повысить свою продуктивность, качество кода
и мастерство, полезно присмотреться к инструментам, которыми вы
пользуетесь в данное время, и узнать, какие еще возможности они в се%
бе таят.
3. Электроинструменты
Программирование и применяемые в его процессе инструменты тесно
связаны между собой, поэтому, чтобы стать суперпрограммистом, вы
должны пользоваться суперинструментом. Что это значит?
Во%первых, нужно хорошо представлять себе, какие инструменты су%
ществуют. В следующем разделе мы рассмотрим список стандартных
инструментов, которые должны быть под рукой у каждого программи%
ста. Не нужно знакомиться со всеми до единого инструментами, при%
сутствующими на рынке: во всяком случае это очень скучная тема для
разговора за обедом. Важным шагом вперед будет хотя бы выяснение
того, какие общие категории инструментов существуют. Это поможет
вам сделать выбор между поиском инструмента для решения опреде%
ленной задачи, написанием собственного инструмента или выполне%
нием задачи вручную. 
Потратьте некоторое время на изучение вопроса. Узнайте, где можно
добыть какие%то из этих инструментов; существуют магазины, специа%
лизирующиеся на продаже инструментов программирования, и мно%
жество сайтов для их загрузки через Интернет. Возможно, у вас уже
стоит нужный инструмент, которым вы никогда не пользовались или
не догадывались о его ценности. Выясните, что умеют эти инструмен%
ты; в результате вы сможете воспользоваться ими с бо]льшей эффек%
тивностью.
4. Какой инструмент необходим?
Ассортимент инструментов для разработки программ ошеломляет.
Потребности, которые часто возникают, известны, и за годы развития
набралось много инструментов, удовлетворяющих любые прихоти. Ес%
ли какая%то задача возникает многократно, можете быть уверены, что
кто%то уже написал инструментарий для ее решения.
5. Резюме
Инструменты обеспечивают возможность создания программного обе%
спечения. Хорошие инструменты значительно облегчают эту задачу.
8 глава
Время испытаний
1. Проверка на подлинность 
Два простых вопроса – Что такое тестирование? и Зачем нужно тес#
тирование? – кажутся до боли очевидными. И тем не менее очень час%
то тестирование осуществляется неправильно или на неправильно вы%
бранном этапе разработки. Умелое тестирование – это искусство. Ре%
альное проведение тестирования – это уровень, которого многие про%
граммисты не достигают; от одного упоминания о тестировании они
покрываются холодным потом. «В тестировании главное правило –
это провести его»
2. Кто, что, когда, зачем?
Чтобы тестирование программного обеспечения было эффективным,
нужно разобраться, для чего мы тестируем, кто этим занимается, что
подразумевает эта процедура и когда можно считать ее законченной.
3. Тестировать легко…
Легко, если делать это плохо, иначе это тяжелый труд. Однако это не
бездумный процесс. Чтобы проверить работоспособность конкретного
фрагмента кода, требуется оснастка, которая демонстрирует: 
• Корректность выходных данных при всевозможных допустимых
вариантах входных.
• Обработку отказа при вводе любых недопустимых данных.
4. Типы тестирования
Есть много разновидностей программных тестов, и ни один из них не
обладает превосходством над остальными. В каждом методе код рас%
сматривается с определенной стороны и выполняется поиск опреде%
ленного класса ошибок. Все тесты необходимы.
5. Выбор контрольных примеров 
для блочного тестирования
Если тестировать нужно, но полное тестирование невозможно, следует
разумно выбрать комплект наиболее эффективных тестов. Для этого
вам понадобится продуманный, методичный план. Можно выбрать
подход стрельбы дробью – повесьте код на стену, а потом стреляйте по
нему из всего, что попадется под руку…
6. Архитектура и тестирование 
Качество написанных вами блочных тестов в значительной степени за%
висит от качества интерфейса, который необходимо протестировать.
Тестирование проще проводить, если вы пишете код именно в расчете
на верификацию и контроль качества. Это достигается с помощью по%
нятных API, уменьшения зависимости от других участков кода и недо%
пущения жестких ссылок на другие компоненты. В результате оказы%
вается проще поместить компоненту в тестовую среду и смоделировать
ее. Если же, напротив, она тесно связана с другими секциями кода,
вам придется переносить эти секции в среду тестирования и организо%
вывать надлежащее взаимодействие секций с вашим блоком. Иногда
это не только трудно, но просто невозможно, что ограничивает ваши
возможности тестирования.
7. Руками не трогать! 
Невозможно заниматься целый день только управлением вручную все%
ми механизмами тестирования. Запуск вручную одного теста за другим
плохо согласуется с моим представлением об эффективной работе про%
граммиста. Многократное повторение регрессивных тестов быстро на%
скучивает. И это не просто скучно, но медленно, неэффективно и под%
вержено ошибкам. Золотое правило тестирования: автоматизируй.
8. Анатомия провала
Как вы поступите, если тестирование обнаружит ошибку в програм%
ме? Прежде чем сломя голову бросаться отлаживать ее, задержитесь
и оцените проблему. Это особенно важно, если вы не хотите (или не мо%
жете) исправить ошибку сразу. Чтобы точно определить суть пробле%
мы, что позволит вам или другому разработчику в будущем вернуться
и решить ее, действуйте следующим образом: 
1. Запишите, что вы пытались сделать в тот момент и какие действия
вызвали сбой.
2. Попробуйте их повторить. Выясните, можно ли воспроизвести про%
блему, как часто она возникает и не выполняются ли в то же время
какие%то другие действия.
3. Опишите сбой. Полностью. Будьте предельно конкретны. Включи%
те следующее:
• контекст проблемы;
• простейший способ ее воспроизведения;
• сведения о повторяемости и частоте возникновения;
• версию программного обеспечения, точный номер сборки и ис%
пользовавшееся оборудование;
• все остальное, что предположительно могло бы иметь отношение.
4. Запишите все и не теряйте! Занесите данные в систему контроля
ошибок, даже если это простая ошибка в коде, которую вы собирае%
тесь исправить сами (см. ниже раздел «Справлюсь ли я сам?»)
5. Напишите простейший контрольный пример, демонстрирующий
сбой, и добавьте его в набор автоматически выполняемых тестов.
Этим вы гарантируете, что ошибка не будет потеряна или забыта,
а когда она будет исправлена, но не повторится в новых разработках. 
9. Справлюсь ли я сам?
Для поиска ошибок требуются методичность и систематичность. Мето%
дичность и систематичность нужны также для учета и управления уст%
ранением ошибок. До того как код выпущен или попал в систему кон%
троля версий, единственный, кто испытывает неприятности из%за этой
ошибки, – вы сами. Но как только вы выпустили код на свободу, он на%
чинает жить своей жизнью. И ошибки в нем касаются уже не только
вас. По мере вступления в игру новых участников правила меняются:
• Программист находит проблемы, глядя на код – свой собственный
или чужой.
• Интегратор кода обнаруживает ошибки в ходе соединения отдель%
ных компонент.
• Отдел QA обнаруживает ошибки во время тестирования.
10. Резюме 
Тестирование – необходимый элемент для создания хорошего про%
граммного продукта. В целом, чем больше тестирования, тем лучше –
хотя на качестве конечного продукта отражается и качество тестов.
Плохие тесты обнаружат мало ошибок, и в результате вы выпустите
продукт с дефектами.
9 глава
Поиск ошибок
1. Реальные факты
Не думаю, что кто%нибудь усаживает студентов%программистов и объ%
ясняет им, как устроена жизнь: «Видишь ли сынок, есть птички
и пчелки. Ах да, забыл про жучков.» «Жучки», или «баги», – это неиз%
менная мрачная сторона создания программ, неизбежная реальность.
Печально, но это так. Существуют целые отделы, даже специальности,
поставленные на борьбу с ними.
2. Природа этого зверя
Вопреки распространенному мнению термин жучок (bug) был в ходу
еще до появления компьютеров. В 1870%х годах Томас Эдисон говорил
о жучках в электрических цепях. История с релейной вычислительной
машиной Mark II Aiken Гарвардского университета является первым
зарегистрированным случаем компьютерного жучка. В 1945 году, ко%
гда первые компьютеры были таких размеров, что занимали целую
комнату, в одно такое помещение залетела бабочка и, сев на какие%то
провода, вызвала аварию системы. В журнале оператора была сделана
запись о первом реальном случае обнаружения компьютерного жучка.
Это событие увековечено экспонатом Смитсоновского института.
3. Борьба с вредителями
Выдергивать сорняки из программ трудно. Нужно обнаружить ошиб%
ку, распознать проблему, искоренить все следы нежелательного пове%
дения, проверить, не проникла ли ошибка в другие места, и постарать%
ся не испортить ничего в коде, проводя все эти действия. Даже первый
шаг – обнаружение ошибки – представляет собой большое затрудне%
ние: человек совершает ошибки при письме, но не меньшее их количе%
ство он делает при чтении. Читая свой текст или код, я, естественно,
вижу то, что хотел написать, а не то, что написал в действительно#
сти. Ошибки в коде не бросаются в глаза. От компилятора помощи то%
же немного; он действует весьма педантично. Компилятор сделает
в точности то, о чем вы просили, а не то, что вы подразумевали.
4. Охота за ошибками
Как искать ошибки? Если бы существовала какая%нибудь простая
трехшаговая процедура, мы бы ее выучили и стали выпускать идеаль%
ные программы. Нет такой процедуры, и наши программы такие, ка%
кие они есть. Попробуем разобраться в опыте поиска ошибок, накоп%
ленном человечеством.
5. Как исправлять ошибки
Этот раздел, как вы заметите, гораздо меньше предыдущего. Как ни
странно. Обычно главную часть проблемы составляет поиск проклятой
ошибки. После того как вы вычислили, где она лежит, исправить ее
можно очевидным образом. 
6. Профилактика 
Всякий скажет вам, что «предохраняться – эффективнее, чем лечить%
ся». Лучший способ не множить ошибки – это не допускать их возник%
новения изначально. К несчастью, я не надеюсь, что мы когда%нибудь
достигнем этого идеала. Поскольку программирование подразумевает
решение задач, оно всегда будет сложным занятием; вы не только
должны правильно решить задачу, но прежде всего должны понимать
задачу в целом. Несмотря на это, тщательно проводимое защитное
программирование позволяет избежать многих проблем. Хороший
стиль программирования подразумевает дисциплину и внимание к де%
талям. Тщательное тестирование предотвращает проникновение оши%
бок в окончательные версии программных продуктов.
7. Спрей от ос, репеллент для мух, липучки…
Есть много полезных средств отладки, и глупо отказываться от них.
Одни интерактивны и позволяют изучать код во время его выполне%
ния, другие неинтерактивны и часто действуют как фильтр кода или
анализатор, выводящий информацию об анализируемой программе.
Научитесь ими пользоваться, и это неизмеримо сократит время, кото%
рое вы тратите на отладку.
8. Резюме
Как смерти и налогов, мы при всех стараниях не сможем избежать
ошибок. Конечно, эффект первых двух обстоятельств можно умерить,
если не упускать из виду ни один новый крем против морщин или при%
менять хитрые финансовые схемы, но если вы не знаете, как посту%
пить, столкнувшись со сбоями в вашей программе, ваш код обречен.
10 глава
Код, который построил Джек 
1. Языковые барьеры
Есть несколько разновидностей языков программирования, в каждой
из которых существует своя механическая процедура построения ис%
полняемой программы из исходного кода. Модели построения разли%
чаются по сложности, и у каждой есть свои сильные и слабые стороны.
2. Делаем слона из мухи
Модели компиляции (и компиляции в байт%коды) сложнее всего в об%
суждении, поэтому рассмотрим, что включает в себя компиляция про%
граммного обеспечения. Просто поразительно, как мало начинающих
программистов действительно понимает это, поэтому мы начнем с ба%
зовых принципов. Если эта тема вам знакома, можете пропустить ее.
3. Выполнение сборки
Мы рассмотрели некоторые главные моменты построения сборки про%
граммы в этом засасывающем болоте создания программного продук%
та. В сущности, в любой процедуре сборки программы есть один или
несколько файлов с исходным кодом на входе и некая выполняемая
программа на выходе. Результатом может быть даже полный дистри%
бутив программы, включая выполняемый файл, файлы подсказки,
программу установки и т. д., которые будут тщательно упакованы
и готовы к записи на CD.
4. Механика сборки 
За этими соображениями качества стоят практические вопросы систе%
мы сборки. Чтобы поговорить о них конкретно, мы подробно обсудим
make, конкретную систему сборки и make%файлы, но не пугайтесь – за
исключением различий в синтаксисе, другие системы сборки следуют
аналогичным соглашениям (даже красивые графические пакеты). 
5. Отпусти меня…
Некоторые сборки имеют особую важность и требуют более тщатель%
ной подготовки. Это финальные сборки, выполняемые со специальной
задачей, а не в ходе разработки. Финальная сборка может быть связа%
на с волнующим событием: выпуском бета%версии, первым официаль%
ным выпуском продукта или выпуском обновления продукта. Это так%
же может быть внутренняя контрольная версия разработчика или про%
межуточная версия для отдела тестирования; такие версии не выходят
за стены компании, но отношение к ним такое же серьезное, как к вы%
пускаемым версиям – что%то вроде учебной тревоги перед окончатель%
ным выпуском.
6. Мастер на все руки
Во многих организациях есть конкретный работник, занимающийся
сборкой, которого часто называют мастером сборки (buildmaster). Его
работа состоит в сопровождении системы сборки. В его обязанности
могут входить планирование и реализация графиков сборки, либо он
выполняет чисто технические функции. Мастер сборки должен глубо%
ко разбираться в системе сборки. Он может настраивать систему, до%
бавлять в нее нужные новые цели, сопровождать сценарии ночной
сборки и т. д. Мастер сборки также ведет документацию по системе
сборки, а возможно, и администрирует систему контроля версий.
7. Резюме
На первый взгляд кажется, что в процедуре сборки программного
обеспечения нет ничего сложного, если правильно выбрать инструмен%
ты. Но этими инструментами нужно уметь пользоваться. Качество
системы сборки имеет первостепенное значение; в отсутствие безопас%
ной, надежной процедуры сборки разработать крепкий код невозмож%
но. Выпустить надежный конечный продукт еще сложнее – для этого
требуются тщательность и точность процедуры. Важно разбираться
в том, как работает система сборки, даже если не требуется ежедневно
вносить в нее изменения.
11 глава
Жажда скорости
1. Что такое оптимизация?
Оптимизация подразумевает улучшение чего%либо, усовершенствова%
ние. В нашем деле она обычно означает, что «код станет выполняться
быстрее», если мерить производительность программы с секундомером.
Но это лишь одна сторона. У разных программ разные требования, и что
«хорошо» для одной, не обязательно «хорошо» для другой. На практике
оптимизация программного обеспечения может иметь разный смысл: 
• Увеличение скорости выполнения программы
• Уменьшение размера исполняемого модуля
• Совершенствование качества кода
• Повышение точности результатов
• Сокращение времени запуска
• Увеличение производительности обработки данных (не обязательно
связанное с ростом скорости выполнения)
• Уменьшение расходов на хранение данных (например, уменьшение
размера базы данных) 
2. От чего страдает оптимальность кода?
Чтобы улучшить свой код, нужно знать, отчего он может работать мед%
ленно, неоправданно расти в размере или иным образом терять качество.
В дальнейшем это поможет нам предложить некоторые методы оптими%
зации кода. Но сейчас полезно уяснить, с чем мы собираемся бороться.
Сложность
Неоправданная сложность губит код. Чем больше работы должен
сделать код, тем медленнее он будет выполняться. Сокращение объ%
ема работ или разбиение задачи на несколько более простых и ко%
ротких могут значительно повысить производительность.
Косвенность 
Превозносится как решение всех проблем программирования и фор%
мулируется в виде известной программистской максимы: любую
проблему можно решить, добавив уровень косвенности. Но косвен%
ность также часто является причиной медлительности кода. Эта
критика часто звучит со стороны процедурных программистов ста%
рого закала в адрес современного OO%проектирования. 
Повторение 
Повторение обязательно снижает эффективность кода, но часто его
можно избежать. Оно случается в разных формах, например, если
не сохранять в буфере результаты трудоемких вычислений или вы%
зовов удаленных процедур. При каждом повторно выполненном
вычислении вы теряете эффективность. Повторение участков кода
неоправданно увеличивает размер выполняемого модуля.
Плохой проект
Это неизбежно: плохое проектирование приводит к плохому коду.
Например, если разнести далеко друг от друга связанные блоки (ска%
жем, разместив их в разных модулях), то их взаимодействие замед%
лится. Плохой проект может привести к возникновению фундамен%
тальных, очень тонких и сложных проблем с производительностью.
Ввод/вывод
Взаимодействие программы с внешним миром – ее ввод и вывод –
это известное узкое место. Если выполнение программы блокирует%
ся в ожидании ввода или вывода данных (пользователем, с диска
или через сеть), она неизбежно теряет в производительности.
3. Доводы против оптимизации
В прежние времена оптимизация имела огромное значение, поскольку
первые компьютеры работали крайне медленно. Чтобы заставить про%
грамму выполниться в течение разумного промежутка времени, требо%
вались высокое мастерство и тонкая шлифовка отдельных машинных
команд. Сейчас такое мастерство утратило былую ценность; револю%
ция, осуществленная персональными компьютерами, изменила харак%
тер разработки программ. Часто мы располагаем избытком вычисли%
тельной мощи – в полную противоположность минувшим временам.
Может сложиться впечатление, что оптимизация больше не нужна.
4. Нужна ли оптимизация
Уяснив, что с оптимизацией связаны опасности, не выкинуть ли на%
всегда из головы идею оптимизировать свой код? Не стоит. Хотя опти%
мизации следует по возможности избегать, однако во многих случаях
она весьма важна. И есть области, в которых она оказывается просто
необходимой.
5. Технические подробности
Каким же образом выполнять оптимизацию? Гораздо важнее уяснить
правильный подход к оптимизации, чем выучить список конкретных
методов. Не бойтесь, мы рассмотрим ниже некоторые приемы про%
граммирования, но их следует рассматривать в контексте более широ%
кой процедуры оптимизации. 
Вот шесть этапов для повышения скорости работы вашей программы:
1. Убедитесь, что программа слишком медленно работает и требует
оптимизации.
2. Определите, какая часть кода самая медленная, и нацельте на нее
свои усилия. 
3. Проверьте производительность кода, выбранного для оптимизации. 
4. Оптимизируйте код. 
5. Протестируйте оптимизированный код и убедитесь, что он сохра%
нил работоспособность (очень существенно). 
6. Проверьте, насколько выросла скорость, и решите, что делать
дальше.
6.Методы оптимизации
Мы долго обсуждали общие вопросы; пора заняться конкретными де%
талями. Следуя описанной выше процедуре оптимизации, вы убеди%
лись, что программа работает неэффективно, и нашли код, больше все%
го повинный в этом. Необходимо переделать его. Что для этого нужно?
 Существуют различные виды оптимизации. Какой из них подойдет
в вашем случае, зависит от конкретной проблемы, вашей цели (напри%
мер, увеличить скорость или уменьшить размер кода) и требуемой сте%
пени оптимизации.
7. Как писать эффективный код 
Если лучше всего отказаться от оптимизации, то как достичь того,
чтобы потребности в повышении эффективности кода вообще не воз%
никало? Для этого нужно проектировать код с учетом его эффектив#
ности и планировать надлежащее качество его работы с самого нача%
ла, а не обстругивать его в последнюю минуту.
8. Резюме
Высокая эффективность кода не столь важна, как некоторым кажет%
ся. Хотя иногда приходится засучить рукава и поковыряться в коде,
в целом нужно активно избегать проведения оптимизации. Поэтому до
начала работы над программным продуктом выясните, какие требова%
ния предъявляются к его производительности. На каждом этапе раз%
работки проверяйте, обеспечивается ли требуемое качество. Тогда оп%
тимизация вам не понадобится. 
12 глава
Комплекс незащищенности
1. Риски
Кому может понадобиться атаковать вашу систему? Тому, кто захочет
воспользоваться тем, чем вы располагаете. Это могут быть: 
• Вычислительные мощности.
• Возможность отправки данных (например, для рассылки спама).
• Ваши конфиденциальные данные.
• Ваши возможности, например определенное программное обеспече%
ние, которое у вас установлено.
• Ваше подключение к представляющим интерес удаленным системам.
2.Наши оппоненты 
Вероятно, трудно поверить в то, что кто%то не пожалеет сил и времени,
чтобы попытаться взломать ваше приложение. Но такие люди есть.
Они талантливы, целеустремленны и весьма терпеливы. Если вы хоти%
те писать защищенные программы, следует знать своего противника.
Тщательно разберитесь в том, что они делают, как это делают, какими
инструментами пользуются и какие задачи перед собой ставят. Только
тогда вы сможете выработать правильную стратегию.
3. Оправдания, оправдания 
Как же атакующим удается так часто взламывать код? Они располага%
ют оружием, которого у нас нет или о котором мы по недостатку обра%
зования ничего не знаем. Инструменты, знания, мастерство – все это
работает на них. Однако они располагают еще одним основополагаю%
щим преимуществом – временем. В условиях промышленного произ%
водства программного продукта разработчики вынуждены вырабаты%
вать максимальный объем кода, который только доступен их силам
(или даже больше), и делать это в сжатые сроки, в противном случае
последствия известны. Этот код должен удовлетворять определенным
требованиям (функциональности, юзабилити, надежности и т. п.), а это
оставляет крайне мало времени на заботу о «второстепенных» качест%
вах, таких как защищенность. У атакующих таких проблем нет; у них
достаточно времени, чтобы изучить все хитрости вашей системы, и
они научились нападать с разных сторон.
4. Ощущение незащищенности
Задача программиста во всей этой сумятице – написать защищенный
код, поэтому проведем обзор слабых мест в наших программах, чтобы
определить, куда направить свои усилия. Существуют конкретные ви%
ды уязвимостей в коде – брешей, которыми может воспользоваться
атакующий.
5. Дела защитные
Стратегии защиты программного обеспечения применимы на разных
уровнях:
Установка системы
Конкретная конфигурация ОС, инфраструктура сети, номера вер%
сий всех работающих приложений имеют важное значение для со%
стояния безопасности.
Конструктивные особенности программной системы
Необходимо принять правильные конструктивные решения, на%
пример, относительно возможности для пользователя оставаться
зарегистрированным в системе произвольно долгое время, способов
связи между подсистемами, выбора протоколов.
Реализация программы
В ней не должно быть дефектов. Наличие ошибок в коде может
быть причиной уязвимости системы.
Процедура эксплуатации системы
При неправильном использовании любая система может представ%
лять собой угрозу. По возможности этому должно препятствовать
правильное проектирование, но пользователям нужно объяснить,
какие их действия могут привести к проблемам. Ведь сколько лю%
дей записывают свое имя и пароль на бумажке, которую кладут ря%
дом с терминалом!
