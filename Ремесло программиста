1 глава
Держим оборону
1. На пути к хорошему коду
Есть огромная разница между кодом, который на первый взгляд работа%
ет, правильным кодом и хорошим кодом. М. Э. Джексон (M. A. Jackson)
писал: «Всякий мудрый программист должен понимать, что есть раз%
ница между тем, чтобы заставить программу работать, и тем, чтобы за%
ставить ее делать это правильно». (Jackson 75) И вот в чем эта разница:
• Легко написать код, который почти всегда работает. Вводишь
в программу обычные данные и получаешь обычные результаты.
Но стоит подать на вход нечто необычное, и все может рухнуть.
• Правильный код не рухнет. Для любого набора входных данных ре%
зультат будет корректен. Однако обычно количество всевозможных
комбинаций входных данных оказывается невероятно большим,
и все их трудно протестировать.
• Однако не всякий правильный код оказывается хорошим – напри%
мер, его логику трудно проследить, код непонятен, его практически
невозможно сопровождать.
2. Готовьтесь к худшему
Предположения служат причиной появления кода с ошибками. Очень
легко предположить следующее:
• Функцию никогда не станут вызывать таким способом. Ей всегда
будут передаваться только допустимые параметры.
• Этот фрагмент кода всегда будет работать, он никогда не сгенериру%
ет ошибку.
• Никто не станет пытаться обратиться к этой переменной, если
я напишу в документации, что она предназначена только для
внутреннего употребления.
3. Что такое защитное программирование
Как следует из названия, защитное программирование – это тщатель%
ное, осторожное программирование. Чтобы построить надежную про%
грамму, мы должны спроектировать каждую компоненту системы так,
чтобы она была как можно лучше защищена. Мы расправимся с непи%
саными допущениями, сделав для них явные проверки в коде. Таким
способом мы попытаемся предотвратить или хотя бы обнаружить такое
обращение к нашему коду, которое вызывает некорректное поведение.
Защитное программирование позволяет обнаружить мелкие проблемы
на ранней стадии, не дожидаясь момента, когда они приведут к серьез%
ным катастрофам. Сплошь и рядом можно столкнуться с тем, как
«профессиональные» разработчики спешат написать код, не дав себе
труда задуматься.
4. Этот страшный, ужасный мир
Защитное программирование повышает безопасность программ, пред%
охраняя от такого рода умышленного злоупотребления. Взломщики и
создатели вирусов не упускают случая воспользоваться неаккуратно
написанным кодом, чтобы получить контроль над приложением и реа%
лизовать свои зловредные планы. Это серьезная угроза в современном
мире программных разработок, которая приводит к огромному ущер%
бу, наносимому продуктивности, финансам и конфиденциальности.
5. Технологии защитного программирования
Защитное программирование предполагает соблюдение ряда разум%
ных правил. Обычно, когда заходит речь о защитном программирова%
нии, людям приходит в голову использовать операторы контроля,
и это правильно. Мы поговорим о них позже. Но существует также мас%
са простых приемов программирования, которые неизмеримо повысят
надежность вашего кода.
6. Выберите хороший стиль кодирования 
и пользуйтесь крепкой архитектурой
Значительной части ошибок можно избежать, придерживаясь доброт%
ного стиля кодирования. Это правило согласуется с остальными глава%
ми данной части. Такие простые вещи, как выбор осмысленных имен
переменных и разумная расстановка скобок, делают код понятнее
и уменьшают шансы пропустить ошибку.
7. Пишите код без спешки
Сплошь и рядом программы пишут сломя голову. Программист быстренько ляпает функцию, пропускает ее через компилятор для проверки синтаксиса, запускает, чтобы убедиться в ее работоспособности,
и переходит к очередной задаче. Такой подход чреват опасными по%
следствиями.
8. Не верьте никому
• Обычный пользователь случайно введет в программу неверные
данные или воспользуется ею некорректно.
• Злоумышленник сознательно попытается заставить программу ве%
сти себя некорректно.
• Клиентский код вызовет вашу функцию, неправильно передав ей
параметры или задав им недопустимые значения.
• Операционная среда не сможет предоставить программе необходи%
мый сервер.
• Внешние библиотеки окажутся некорректными и не выполнят те
контракты по интерфейсам, на которые вы полагались.
9. Стремитесь к ясности, а не к краткости
Когда встает выбор между кратким (но непонятным) и ясным (но скуч%
ным) кодом, делайте его в пользу того кода, смысл которого понятен,
даже если он менее элегантен. Например, сложные арифметические
выражения разбивайте на последовательность отдельных операторов,
логика которых понятнее.
10. Не позволяйте никому лезть туда, где ему нечего делать
• В объектно%ориентированных языках доступ к внутренним данным
класса запрещается путем объявления его закрытым. В C++ можно
воспользоваться идиомой Чеширского кота (или pimpl) – стандарт%
ным приемом, употребляемым для выведения внутренней структу%
ры класса из его открытого файла заголовка. (Meyers 97) 
• В процедурных языках также можно воспользоваться идеями объ%
ектно%ориентированной упаковки, заключив закрытые данные внут%
ри непрозрачных типов и обеспечив корректные операции над ними. 
• Дайте всем переменным минимально необходимую область видимо%
сти; не делайте их глобальными, если в этом нет необходимости. Ес%
ли их можно сделать локальными для функции, не объявляйте их
на уровне файла. Если их можно сделать локальными для цикла, не
объявляйте их на уровне функции.
11. Включайте вывод всех предупреждений при компиляции
Если ваш код изобилует опасными конструкциями, такие предупреж%
дения могут занять многие страницы. К сожалению, по этой причине
очень часто отключают вывод предупреждений компилятором или
просто не обращают на них внимания. Так поступать не следует.
Всегда включайте вывод предупреждений компилятором, и если ваш
код генерирует предупреждения, немедленно исправьте его, чтобы та%
ких сообщений больше не было. Нельзя успокаиваться, пока компиля%
ция не станет проходить гладко при включенном выводе предупрежде%
ний. Они существуют не зря. Даже когда вам кажется, что какое%то
предупреждение несущественно, добейтесь его исчезновения, потому
что в один прекрасный день из%за него вы не заметите того предупреж%
дения, которое окажется действительно важным.
12. Пользуйтесь средствами статического анализа
Предупреждения компилятора представляют собой результат частич%
ного статического анализа кода – контроля кода, проводимого перед
запуском программы.
13. Применяйте безопасные структуры данных
Вероятно, самым распространенным видом уязвимостей в программах
является переполнение буфера. Оно возникает из%за небрежного при%
менения структур данных фиксированного размера. Если ваш код за%
писывает данные в буфер, не проверив предварительно его размер, то
возникает опасность записи за концом буфера.
14. Проверяйте все возвращаемые значения
Если функция возвращает значение, то делает это не зря. Проверяйте
возвращаемое значение. Если это код ошибки, нужно ее обработать.
Не допускайте появления в программе незамеченных ошибок; в итоге
поведение программы может стать непредсказуемым.
15. Аккуратно обращайтесь с памятью 
(и другими ценными ресурсами)
Будьте скрупулезны и освобождайте все ресурсы, которые захватывае%
те во время выполнения. Чаще всего имеется в виду оперативная па%
мять, но это не единственный ресурс. К другим видам ценных ресурсов,
которые нужно беречь, относятся файлы и блокировки потоков. Рас%
поряжайтесь своим добром экономно.
16. Инициализируйте все переменные там, где вы их объявили
Это проблема ясности. Смысл каждой переменной становится ясен, ес%
ли вы инициализируете ее. Опасно полагаться на эмпирические пра%
вила типа: «Раз я ее не инициализировал, значит, ее начальное значе#
ние мне неважно». Код со временем развивается. Отсутствие началь%
ного значения на каком%то этапе может превратиться в проблему.
17. Объявляйте переменные как можно позже
Благодаря этому переменная будет располагаться ближе к месту сво%
его использования и не станет мешаться в других частях кода. Кроме
того, понятнее станет код, в котором участвует эта переменная. Вам не
придется рыскать, выясняя тип и значение переменной: расположен%
ное рядом объявление сделает их очевидными.
18. Пользуйтесь стандартными средствами языка
C и C++ в этом отношении представляют собой кошмар. Их специфи%
кации существуют во многих вариантах, а поведение в наименее ясных
ситуациях не определено и оставлено на усмотрение конкретных реа%
лизаций. На сегодняшний день существует множество компиляторов,
обладающих тонкими различиями. В целом они совместимы между со%
бой, но оставляют вам достаточно возможностей свернуть себе шею.
19. Пользуйтесь хорошими средствами регистрации 
диагностических сообщений
Когда пишут новый код, то часто включают в него много операторов
вывода диагностики, чтобы разобраться в происходящем в программе.
Следует ли удалить их в конце работы? Сохранив их, вы облегчите
себе жизнь в будущем, если придется вернуться к этому коду, особен%
но если можно управлять выводом диагностики.
20. Выполняйте приведение типов с осторожностью
Большинство языков позволяет приводить (преобразовывать) данные
из одного типа в другой. Эта операция не всегда проходит успешно. Ес%
ли вы попытаетесь преобразовать 64%разрядное целое в меньший, 8%раз%
рядный тип, то что произойдет с 56 оставшимися битами? Среда вы%
полнения может неожиданно сгенерировать исключительную ситуа%
цию, а может исказить ваши данные, ничего при этом не сообщив.
Программисты часто не задумываются над такого рода вещами, а по%
тому их программы ведут себя неожиданным образом.
21. Подробности
Определяйте поведение по умолчанию
В большинстве языков есть оператор switch (переключатель), позво%
ляющий любую неожиданность обработать в группе default (по
умолчанию). Если попадание в default является ошибкой, явно от%
разите это в коде. Если ошибки нет, также отразите это в коде, и то%
гда сопровождающему код программисту станет все ясно.
Аналогично, если вы пишете оператор if без предложения else, за%
думайтесь, не следует ли обрабатывать логический случай по умол%
чанию.
Пользуйтесь идиомами языка
Следуя этому простому совету, вы гарантируете, что ваш код будет
понятен читающим его. Они реже будут ошибаться.
Проверяйте числовые результаты
Даже самые простые вычисления могут приводить к переполнению
или потере точности. Будьте настороже. Спецификации языков и ба%
зовые библиотеки предоставляют механизмы для определения до%
пустимых значений стандартных типов данных – воспользуйтесь
ими. Вы должны знать, какие числовые типы существуют и для ка%
ких целей их лучше применять.
Проверяйте допустимость каждого вычисления. Например, следи%
те за тем, чтобы ваши величины не приводили к делению на ноль.
Соблюдайте защищенность констант
Особенно это облегчает жизнь при программировании на C/C++. Ста%
райтесь объявлять как const все, что только можно. Этим достигают%
ся две цели: квалификаторы const способствуют документированию
кода и позволяют компилятору обнаруживать глупые ошибки. Он не
позволит вам изменить данные, модификация которых запрещена.
22. Ограничения
. Есть несколько вариантов реакции программы:
• Сделать вид, что ничего не случилось, и надеяться на лучшее.
• Оштрафовать на месте и разрешить дальнейшее движение (напри%
мер, напечатать диагностическое предупреждение или записать его
в журнал).
• Сразу арестовать; запретить двигаться дальше (например, прервать
выполнение программы контролируемым или неконтролируемым
образом).
Существует несколько разных сценариев использования ограничений:
Входные условия
Эти условия должны быть выполнены до входа в раздел кода. Если
входное условие не выполнено, это означает, что в коде клиента
есть ошибка.
Выходные условия
Эти условия должны быть выполнены после выхода из блока кода.
Если выходное условие не выполнено, это означает, что в коде по%
ставщика есть ошибка.
Инварианты
Эти условия должны быть выполнены при достижении в ходе вы%
полнения программы определенной точки, например между прохо%
дами цикла, при вызове методов и т. п. Невыполнение инварианта
означает, что в логике программы есть ошибка.
Операторы контроля
Это любое другое утверждение относительно состояния программы
в данный момент.
23. Какие ограничения налагать
Есть несколько проблем, которые можно решать с помощью ограниче%
ний. Например, можно делать следующее:
• Проверять, чтобы все обращения к массивам не выходили за их гра%
ницы.
• Контролировать неравенство нулю указателей перед их разымено%
ванием.
• Проверять допустимость параметров функций.
• Контролировать результаты функций, прежде чем их возвращать.
• Проверять состояние объекта перед операциями с ним.
• Защищать те участки кода, где должны быть комментарии. Они не
должны получать управление.
24. Снятие ограничений
Такого рода проверка ограничений обычно требуется только на этапах
разработки и отладки программы. После того как мы воспользовались
ограничениями, чтобы убедить себя (возможно, ошибочно) в правиль%
ности логики программы, следовало бы убрать их, чтобы готовая про%
грамма не делала лишней работы.
25. Резюме
Необходимо писать не просто корректный, но хороший код. Для этого
нужно документировать все сделанные предположения. В результате
код станет легче сопровождать и в нем окажется меньше места для
ошибок. Защитное программирование ориентировано на то, чтобы быть
готовым к худшему, что может случиться. Данная технология препят%
ствует превращению случайных огрехов в трудноуловимые ошибки.
2 глава
Тонкий расчет
1. Да в чем проблема?
Расположение и представление кода оказываются предметом разно%
гласий в большинстве современных языков программирования. Про%
извольное форматирование, позволяющее выразить свою художест%
венную индивидуальность, вошло в моду в начале 1960%х годов с появ%
лением Алгола: существовавшие к тому времени версии Fortran до%
пускали меньше свободы в формате. В последующем лишь очень
немногие языки отошли от такого подхода к свободе форматирования.
2. Знайте своих клиентов
Чтобы написать эффективный исходный код, необходимо понимать,
кто его будет читать. Если придется кого%то поставить в трудное поло%
жение, выясните, перед кем потом извиняться. В действительности,
есть три круга адресатов вашего кода:
Вы сами
У меня такой плохой почерк, что иногда мне самому трудно его ра%
зобрать. Это практически невозможно, если я не ставлю себе задачу
писать разборчиво. То же самое происходит и с кодом. Созданное ва%
ми должно быть понятно не только сразу после написания, но и по
прошествии лет. Кто мог подумать, что придется вернуться к (отно%
сительно) архаичному коду на COBOL, чтобы исправить в нем
ошибки, связанные с Y2K?
Компилятор
Компилятору все равно, как выглядит ваш код, – лишь бы в нем не
было синтаксических ошибок. Ему абсолютно безразлично, какую
задачу этот код решает. Можно подробно описать в комментариях,
что должна делать функция, но компилятор никогда не сообщит вам,
действительно ли она выполняет то, что сказано в комментариях.
Если код корректен, среда разработки будет вполне удовлетворена.
Прочие лица 
Это самая важная аудитория, интересы которой часто меньше всего
учитываются. 
Вам кажется, что хотя вы работаете в составе команды, никто нико%
гда не станет смотреть ваш код. Это ошибочное мнение.
Вы пишете какой%то код для себя дома. Стоит ли заботиться о его кра%
соте? Если «да», то в чем польза? В выработке качеств, которые дела%
ют вас профессионалом. У вас появляется прекрасная возможность
продемонстрировать настоящую дисциплину в проекте, когда никто
не оказывает на вас давления. Это возможность выработать хорошие
манеры. Если вы не справитесь с задачей в таких условиях, то неуди%
вительно, что у вас не хватит дисциплины в реальных проектах. 
3. Что такое хорошее представление?
Расположение кода должно передавать его смысл, а не скрывать.
Я предлагаю следующие критерии качества стиля представления кода.
Единообразие
Принципы отступов в коде должны быть одинаковы во всех частях
проекта. Не меняйте стиль в середине пути. Это не только выглядит
непрофессионально, но и может ввести в заблуждение, создавая
впечатление отсутствия связи между файлами с исходным кодом.
Отдельные правила представления должны быть внутренне непроти%
воречивыми. Расположение фигурных и квадратных скобок и т. п.
в различных ситуациях должно соответствовать единым правилам.
Количество пробелов в отступах должно быть всегда одинаковым.
Керниган и Ричи, основоположники C, подчеркивают важность
правильных отступов и затем говорят: «Положение скобок менее
важно, хотя люди склонны проявлять фанатизм в таких вопросах.
Мы выбрали один из нескольких популярных стилей. Выберите тот
стиль, который вам больше подходит, и точно ему следуйте». (Ker%
nighan Ritchie 88)
Стандартность
Разумно принять какой%нибудь из господствующих ныне стилей,
а не изобретать собственные правила отступа. Так будет проще для
тех, кто станет читать ваш код. И меньше шансов, что ваш стиль
вызовет у них отвращение.
Краткость
Можете ли вы кратко описать свою стратегию отступов? Подумайте
над этим. Если вы делаете нечто, пока не произойдет то#то и то#
то, а тогда вы будете делать это, если выполняется X; в противном
случае вы станете делать нечто другое в зависимости от…
Кому%то может потребоваться дополнить написанный вами код, и де%
лать это ему следует, придерживаясь того же стиля. Если его трудно
ухватить, можно ли считать такой стиль представления удачным?
4. Размещение скобок
Для иллюстрации влияния, которое представление оказывает на ис%
ходный код, и компромиссов, на которые приходится идти при выборе
стиля, разберем конкретный случай, связанный с важной проблемой
расположения кода C. Рассматривая варианты, возникающие в этой
одной простой области, мы продемонстрируем важность представле%
ния и степень его влияния на код.
5. Скобки в стиле K&R
Стиль K&R относится к старейшим, будучи предложенным основопо%
ложниками языка C, Керниганом и Ричи, в книге «Язык программи%
рования C» (Kernighan Ritchie 88). По этой причине его часто считают
исходным и лучшим. На него повлияла необходимость отобразить как
можно больше информации на маленьком экране. Пожалуй, это пре%
валирующий стиль для кода Java.
6. Расширенный стиль скобок
Более свободное расположение кода достигается в расширенном (ex#
dented) стиле, называемом также стилем Олмана. Лично мне он нра%
вится больше прочих.
7. Стиль Уайтсмита (с отступами)
Стиль с отступами менее распространен, хотя и встречается. Фигур%
ные скобки при этом имеют тот же отступ, что и код. Он получил на%
звание стиля Уайтсмита, поскольку применялся в примерах для
Whitesmiths C – раннего компилятора с языка С.
8. Другие стили скобок
Существуют и другие стили. Например, стиль GNU занимает промежу%
точное положение между расширенным стилем и стилем с отступами:
скобки располагаются посередине каждого уровня отступа. Есть и гиб%
ридные стили: стиль кода ядра Linux наполовину представляет K&R,
наполовину – стиль Олмана. Большинство программирующих на C#
тоже комбинирует стили расположения.
9. Единственно верный стиль
Поняв, что такое правильный стиль кодирования, на что он влияет
и почему необходим, нужно выбрать для себя что%то подходящее. Вот
тут и начинается столкновение. Последовательности одного религиоз%
ного течения в представлении ведут борьбу с проповедниками другого,
порождая гражданские войны между программистами. Но настоящий
мастер не ввязывается в эти мелкие дрязги, предпочитая взвешенный
подход.
10. Внутрифирменные стили 
(и когда их придерживаться)
Важность и полезность внутрифирменных стилей обусловлена рядом
причин. Когда все танцуют под одну дудку, исходный код оказывается
полностью единообразным и однородным. Что в этом хорошего? Улуч%
шается качество кода и растет надежность разработки программного
обеспечения. И вот почему:
• Любой код, выходящий за пределы организации, имеет аккуратное
представление и согласованность, создавая впечатление хорошей
продуманности. Наличие в одном проекте разнородных стилей соз%
дает впечатление неряшливости и непрофессионализма.
• Компания может быть уверена в том, что программы пишутся со%
гласно единому стандарту, включающему в себя определенные
идиомы и методологии. Это не гарантирует получение хорошего ко%
да, но дает некоторую защиту от появления плохого кода.
• Компенсируются недостатки инструментария: по разному настро%
енные IDE будут вступать в конфликт между собой, разрывая код
на части и досаждая форматированием. Стандарт создает ровную
почву (и общего врага для всех программистов).
• Привлекательна возможность сразу оценить состояние кода, напи%
санного коллегами, и быстро сделать необходимые изменения при
сопровождении. Меньше времени тратится на чтение, а значит, бе%
регутся финансовые ресурсы компании.
• Поскольку программисты перестанут непрерывно заново формати%
ровать код в соответствии со своими эстетическими пристрастия%
ми, система управления версиями станет намного эффективнее. Ес%
ли один программист будет переформатировать код второго, чтобы
привести его к «своему» стилю, это отразится на работе утилит,
сравнивающих версии. Многие из них действуют довольно грубо
и покажут массу несущественных различий в расстановке пробель%
ных символов и скобок.
11. Установка стандарта
Сложность задачи зависит от особенностей членов вашего коллектива:
• Сколько всего программистов
• Как каждый в отдельности пишет код
• Насколько схожи между собой их стили программирования
• Заинтересованы ли они в наличии стандарта
• Готовы ли они к тому, чтобы изменить свой стиль
12. Религиозные войны?
Вести религиозные войны по поводу форматирования кода – пустая
трата времени; есть гораздо более важные проблемы, заслуживающие
вашего внимания. Но будьте осторожны: формат кода – не единствен%
ное больное место у программистов. Помимо него существуют выбор
редактора, компилятора, методологии, Настоящего языка1 и т. д.
13. Резюме
Представление – одна из главных характеристик, отличающих хоро%
ший код от плохого. Программист может многое узнать по внешнему
виду кода, поэтому стоит позаботиться о его надлежащем форматиро%
вании. Важно уметь толково расположить код в соответствии с прави%
лами существующего в фирме стандарта кодирования, обеспечив его
максимальную понятность.
3 глава
Что в имени тебе моем?
1. Зачем нужны хорошие имена?
Нужно тщательно выбирать имена для своих объектов. Ведь исходный
код должен быть понятен. Имя создает путь к пониманию, контролю
и овладению. Если правильно выбрать имя, по нему можно понять на#
значение объекта. 
2. Каким объектам мы даем имена?
Задумаемся как программисты над тем, каким объектам мы даем име%
на и какие имена мы им даем. Сначала о том, какие конструкции ча%
ще всего получают от нас имена, когда мы пишем код:
• Переменные
• Функции
• Типы (классы, перечисления, структуры, определения типов)
• Имена пространств C++ и пакетов Java
• Макросы
• Файлы с исходным текстом
3. Игра в названия
Какое назначить имя? Техника создания любого имени зависит от
стандарта кодирования, которого вы придерживаетесь. Однако хотя
стандарт и определяет некоторые правила составления имен, он не бы%
вает настолько конкретным, чтобы определить правильное имя любо%
го элемента, входящего в программу. 
4. Технические подробности
В следующих разделах обсуждается, как выбирать имена в каждой из
перечисленных категорий объектов. Даже если у вас многолетний опыт
программирования, обзор существующих принципов формирования
имен может оказаться полезен и для вас.
5. Роза пахнет розой
Значение имени больше, чем может показаться на первый взгляд, и су%
ществует масса соображений при выборе имени для программного объ%
екта. Какими главными принципами следует руководствоваться? 
Чтобы выбрать хорошее имя, нужно:
• Соблюдать единообразие
• Связывать имя с содержимым
• Извлекать из имен практическую пользу
6. Резюме
Наши предки знали в те времена то, что хорошие программисты знают
сейчас: очень важно правильно выбрать имя. Хорошие имена не про%
сто удовлетворяют эстетическую потребность – они передают инфор%
мацию о структуре кода. Они служат важным средством, позволяю%
щим облегчить понимание и сопровождение кода. 
4 глава
Литературоведение 
1. Самодокументируемый код
Гордиться тут, собственно, нечем. Сложная и имеющая практическую
ценность программа требует большого мастерства. Практика показы%
вает, что читать компьютерные программы гораздо сложнее, чем пи%
сать их. Всякий, кто знаком с Perl, это подтвердит: данный язык пред%
ставлялся как предельный случай «напиши и забудь». И вправду, ста%
рый код Perl может казаться совершенно непостижимым. Однако не%
понятный код можно написать на любом языке, и особых стараний
для этого не требуется.
2. Техника написания самодокументируемого кода
Обычно считается, что самодокументируемый код должен содержать
в себе обилие комментариев. Хорошие комментарии, несомненно, нуж%
ны, но ими дело не ограничивается. На самом деле нужно стремиться
избегать комментариев путем написания такого кода, в котором в них
нет необходимости.
3. Практические методологии 
самодокументирования
В завершение этой главы мы сравним два конкретных метода докумен%
тирования кода. Помните, что эти методы менее предпочтительны, чем
те, которые мы уже рассмотрели. Как сказано у Кернигана и Плоэра,
«нужно не документировать плохой код, а переписать его заново».
4. Резюме 
Мы пишем код для того, чтобы передать информацию. Код без доку%
ментации опасен и малоинформативен. Его трудно сопровождать.
Плохая документация также создает проблемы: она либо вводит чита%
теля в заблуждение, либо делает программу ненадежной и требующей
дополнительных разъяснений.
5 глава
1. Что есть комментарий в коде?
Синтаксически комментарий представляет собой блок исходного тек%
ста, который игнорируется компилятором. Поместить в него можно
что угодно – хоть имена своих внуков, хоть цвет любимой рубашки;
компилятор и глазом не моргнет, встретив такое в файле.
2. Как выглядят комментарии?
Комментарии C помещаются в блоках между комбинациями /* и */
и могут занимать произвольное количество строк. В C++, C99, C#
и Java есть, кроме того, однострочные комментарии, следующие за //.
В других языках есть аналогичные средства комментирования блока#
ми и в строке, но синтаксис иной. 
3. Сколько комментариев требуется
Тех, кто изучает программирование, заставляют писать комментарии,
и в большом количестве. Но слишком обширные комментарии могут
быть недостатком – важные фрагменты кода оказываются затерянны%
ми среди потока слов. Когда вам приходится продираться через про%
странные комментарии, вместо того чтобы читать сам код, качество
последнего снижается. 
4. Что помещать в комментарии? 
Лучше совсем без комментариев, чем плохие комментарии – они дез%
информируют читателя и вводят его в заблуждение. Что же следует
помещать в комментарии? Вот несколько основных советов, как повы%
сить качество комментариев.
5. На практике
Проиллюстрируем принципы комментирования следующим приме%
ром. Рассмотрим фрагмент кода C++. Даже если не критиковать идио%
матическую сторону, код не вполне понятен.
6. Замечание об эстетичности
Несомненно, вам приходилось сталкиваться с горячими обсуждения%
ми того, как нужно форматировать комментарии. Я не намерен на%
ставлять вас на путь истинный в этом вопросе (его просто не существу%
ет), но есть ряд важных аспектов, которые нужно учитывать. Отнеси%
тесь к ним как к общим принципам, сообразуясь с вашими личными
вкусами, а не как к безусловным требованиям. 
7. Работа с комментариями 
Комментариями удобно пользоваться при написании кода. Но не зло%
употребляйте ими.
8. Резюме
Мы пишем много комментариев. Это вызвано тем, что мы пишем мно%
го кода. Важно научиться писать правильные комментарии, иначе
наш код может потонуть под грузом бестолковых или устаревших
комментариев. 
Не нужно переоценивать значение комментариев; благодаря хорошим
комментариям плохой код лучше не станет. Целью должно быть напи%
сание самодокументируемого кода, для которого не требуются ника%
кие комментарии.
6 глава
Людям свойственно ошибаться
1. Откуда что берется
Ошибки были и будут. Неприятные результаты могут быть следствием
почти любой операции. Это не то же самое, что дефект программы, по%
скольку вы заранее знаете, что может произойти ошибка. Например,
вам нужно открыть файл базы данных, а он оказывается удален, или
диск переполнен, и операция записи становится невозможной, или не%
доступен требуемый веб%сервис. 
Ошибки пользователя
Глупый юзер варварски обращается с вашей любимой программой.
Возможно, он ввел неверные данные или попытался выполнить со%
вершенно бессмысленную операцию. Хорошая программа укажет
на ошибку и поможет пользователю исправить ее. Она не станет из%
деваться над ним или жаловаться непонятно на что. 
Ошибка программиста
Пользователь действовал правильно, но код некорректен. Где%то
есть дефект, недосмотр программиста, с которым пользователь ни%
чего не может сделать (кроме как постараться избегать в будущем).
В идеале таких ошибок быть не должно. 
Здесь возникает замкнутый круг: необрабатываемые аварийные си%
туации приводят к ошибкам в программе. А эти ошибки могут при%
водить к возникновению аварийных ситуаций в других местах ко%
да. Поэтому мы считаем защитное программирование важной тех%
нологией.
Исключительные обстоятельства
Пользователь действовал правильно, и программист ничего не напу%
тал. Вмешалась неверная судьба, и мы столкнулись с чем%то, чего
нельзя было избежать. Разорвалось сетевое соединение, кончились
чернила в принтере или не осталось места на диске.
2. Механизмы сообщения об ошибках
Есть несколько стандартных стратегий передачи информации об ошиб%
ке в клиентский код. Вы можете встретить код, в котором применяется
любая из них, поэтому каждый из имеющихся диалектов должен быть
вам понятен. Обратите внимание на особенности этих методов сообще%
ния об ошибках и на преимущества тех или иных из них в отдельных
ситуациях.
3. Обнаружение ошибок
Возвращаемые значения
Успешно ли выполнилась функция, определяется по возвращаемо%
му ею значению. Эта проверка на отказ тесно связана с самим вызо%
вом функции; подразумевается, что, выполняя его, вы проверяете,
был ли он успешным. Учитывать полученный результат или нет –
дело ваше.
Переменные состояния ошибки
После вызова функции нужно рассмотреть значение переменной со%
стояния ошибки. Для переменной errno в модели C нет необходимо%
сти проверять наличие ошибки после каждого обращения к функ%
ции. Сбросьте значение errno, а затем последовательно вызовите
любое число стандартных библиотечных функций. После этого по%
смотрите на значение errno. Если оно соответствует коду ошибки,
значит, одна из вызывавшихся функций дала сбой. Вы не узнаете,
какая именно, но иногда можно воспользоваться и таким упрощен%
ным способом обнаружения ошибок. 
Исключительные ситуации
Если одна из подчиненных функций сгенерировала исключитель%
ную ситуацию, вы можете либо перехватить ее, либо игнорировать
и позволить ей подняться на более высокий уровень. Обоснованное
решение можно принять лишь тогда, когда известно, какие исклю%
чительные ситуации могут генерироваться. Такое знание может
дать вам документация (если она заслуживает доверия).
В Java исключительные ситуации реализованы так, что эта доку%
ментация находится в самом коде. Программист обязан написать
для каждого метода спецификацию исключений, указав, какие ис%
ключительные ситуации могут генерироваться. Java – единствен%
ный из основных языков программирования, который предъявляет
такие требования. Исключение, отсутствующее в списке, не сможет
проскочить, потому что компилятор осуществляет статическую про%
верку с целью не допустить этого.1
Сигналы
Есть лишь один способ обнаружить сигнал: установить для него об%
работчик. Делать это необязательно. Можно не устанавливать ника%
ких обработчиков сигналов и сохранить поведение по умолчанию.
4. Обработка ошибок
Где она возникла
Это совсем не то место, где она станет обрабатываться. Где находит%
ся источник – в базовой системной компоненте или периферийном
модуле? Эти данные могут присутствовать в сообщении об ошибке
либо быть получены вручную. 
Что вы пытались сделать?
Что спровоцировало ошибку? В этом может быть ключ ко всем вос%
становительным действиям. В отчете об ошибке такие сведения
встречаются редко, но по контексту можно выяснить, какая функ%
ция была вызвана. 
Почему возник сбой
В чем суть проблемы? Нужно точно узнать, что случилось, а не про%
сто установить класс ошибки. Какая часть приведшей к ошибке
операции успела выполниться? Прекрасно, если выполнилось все
или ничего, но обычно программа оказывается в некоем промежу%
точном состоянии.
Когда это случилось
Это локализация ошибки по времени. Произошел ли отказ только
что или это проблема двухчасовой давности, известившая о себе
только сейчас? 
Степень тяжести ошибки
Одни проблемы опаснее других, хотя при обнаружении они все рав%
нозначны – не разобравшись с проблемой и не найдя ее решения,
нельзя двигаться дальше. Степень тяжести обычно определяет вы%
звавший уровень исходя из того, насколько легко возобновить рабо%
ту или найти обходной путь.
Как исправить ошибку
Решение может быть очевидным (например, вставить дискету и по%
вторить операцию) или не совсем (например, потребуется модифи%
цировать параметры функции, сделав их совместимыми). Чаще все%
го вывод делается на основании других источников информации.
5. Подымаем скандал
Мы уже довольно долго занимаемся ошибками, которыми нас снабжа%
ют другие. Пора поменяться местами и самим выступить в роли нехо%
роших мальчиков: будем генерировать ошибки. Если вы пишете функ%
цию, в ней могут происходить неправильные вещи, о которых нужно
сообщать вызывающему. И делать это необходимо – не проходите мимо
сбоев. Даже если вы уверены, что вызвавший не будет знать, что делать
с проблемой, вы должны проинформировать его. Не пишите лживый
код, который якобы делает то, чего на самом деле он не выполняет.
6. Управление ошибками
Стандартный принцип для генерации и обработки ошибок требует нали%
чия единообразной стратегии обработки сбоев, в каком бы месте они ни
проявились. Вот общие административные соображения, относящие%
ся к возникновению, обнаружению и обработке программных ошибок:
• Избегайте ситуаций, чреватых ошибками. Лучше напишите код,
который гарантированно будет работать. Например, чтобы не воз%
никало ошибок выделения памяти, заранее позаботьтесь о резерви%
ровании достаточных ресурсов. Когда у вас обеспечен пул памяти,
программа не может испытывать недостатка в памяти. Конечно,это осуществимо, только если заранее известно, сколько нужно ре%
сурсов, но часто именно так и бывает.
• Определите возможное поведение вашей программы или функции
в необычных обстоятельствах. Исходя из этого установите, на%
сколько устойчивым должен быть код и насколько тщательной –
обработка ошибок. Не получится ли так, что функция, не привле%
кая внимания, сгенерирует скверные выходные данные согласно
классическому принципу GIGO?1
• Четко распределите между компонентами обязанности по обработ%
ке тех или иных ошибок. Объявите это в интерфейсе модуля. Пусть
ваш клиент знает, что будет работать всегда, а что может в один
прекрасный день отказать.
• Проконтролируйте свой стиль программирования: в какой момент
вы пишете код обработки ошибок? Не откладывайте его на буду%
щее; обязательно что%нибудь пропустите. Не откладывайте написа%
ние обработчиков до того времени, когда тестирование выявит про%
блемы – это не инженерный подход. 
• Если вы перехватили ошибку, что это – симптом или причина? Вы
можете обнаружить источник проблемы, которую нужно исправ%
лять тут же, или признак более застарелой проблемы. В последнем
случае не нужно писать много кода в этом месте; лучше поместить
его там, где он более уместен – в более раннем обработчике ошибки.
7. Резюме
Людям свойственно ошибаться (но у компьютеров это тоже хорошо по%
лучается). Исправление ошибок – святое дело.
На всякую написанную вами строчку кода должен приходиться надле%
жащий объем кода для доскональной проверки и обработки ошибок.
Программа без строгой обработки ошибок не может быть надежной.
В один прекрасный день случится какая%то неясная ошибка, и в ре%
зультате программа рухнет.
