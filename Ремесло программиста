1 глава
Держим оборону
1. На пути к хорошему коду
Есть огромная разница между кодом, который на первый взгляд работа%
ет, правильным кодом и хорошим кодом. М. Э. Джексон (M. A. Jackson)
писал: «Всякий мудрый программист должен понимать, что есть раз%
ница между тем, чтобы заставить программу работать, и тем, чтобы за%
ставить ее делать это правильно». (Jackson 75) И вот в чем эта разница:
• Легко написать код, который почти всегда работает. Вводишь
в программу обычные данные и получаешь обычные результаты.
Но стоит подать на вход нечто необычное, и все может рухнуть.
• Правильный код не рухнет. Для любого набора входных данных ре%
зультат будет корректен. Однако обычно количество всевозможных
комбинаций входных данных оказывается невероятно большим,
и все их трудно протестировать.
• Однако не всякий правильный код оказывается хорошим – напри%
мер, его логику трудно проследить, код непонятен, его практически
невозможно сопровождать.
2. Готовьтесь к худшему
Предположения служат причиной появления кода с ошибками. Очень
легко предположить следующее:
• Функцию никогда не станут вызывать таким способом. Ей всегда
будут передаваться только допустимые параметры.
• Этот фрагмент кода всегда будет работать, он никогда не сгенериру%
ет ошибку.
• Никто не станет пытаться обратиться к этой переменной, если
я напишу в документации, что она предназначена только для
внутреннего употребления.
3. Что такое защитное программирование
Как следует из названия, защитное программирование – это тщатель%
ное, осторожное программирование. Чтобы построить надежную про%
грамму, мы должны спроектировать каждую компоненту системы так,
чтобы она была как можно лучше защищена. Мы расправимся с непи%
саными допущениями, сделав для них явные проверки в коде. Таким
способом мы попытаемся предотвратить или хотя бы обнаружить такое
обращение к нашему коду, которое вызывает некорректное поведение.
Защитное программирование позволяет обнаружить мелкие проблемы
на ранней стадии, не дожидаясь момента, когда они приведут к серьез%
ным катастрофам. Сплошь и рядом можно столкнуться с тем, как
«профессиональные» разработчики спешат написать код, не дав себе
труда задуматься.
4. Этот страшный, ужасный мир
Защитное программирование повышает безопасность программ, пред%
охраняя от такого рода умышленного злоупотребления. Взломщики и
создатели вирусов не упускают случая воспользоваться неаккуратно
написанным кодом, чтобы получить контроль над приложением и реа%
лизовать свои зловредные планы. Это серьезная угроза в современном
мире программных разработок, которая приводит к огромному ущер%
бу, наносимому продуктивности, финансам и конфиденциальности.
5. Технологии защитного программирования
Защитное программирование предполагает соблюдение ряда разум%
ных правил. Обычно, когда заходит речь о защитном программирова%
нии, людям приходит в голову использовать операторы контроля,
и это правильно. Мы поговорим о них позже. Но существует также мас%
са простых приемов программирования, которые неизмеримо повысят
надежность вашего кода.
6. Выберите хороший стиль кодирования 
и пользуйтесь крепкой архитектурой
Значительной части ошибок можно избежать, придерживаясь доброт%
ного стиля кодирования. Это правило согласуется с остальными глава%
ми данной части. Такие простые вещи, как выбор осмысленных имен
переменных и разумная расстановка скобок, делают код понятнее
и уменьшают шансы пропустить ошибку.
7. Пишите код без спешки
Сплошь и рядом программы пишут сломя голову. Программист быстренько ляпает функцию, пропускает ее через компилятор для проверки синтаксиса, запускает, чтобы убедиться в ее работоспособности,
и переходит к очередной задаче. Такой подход чреват опасными по%
следствиями.
8. Не верьте никому
• Обычный пользователь случайно введет в программу неверные
данные или воспользуется ею некорректно.
• Злоумышленник сознательно попытается заставить программу ве%
сти себя некорректно.
• Клиентский код вызовет вашу функцию, неправильно передав ей
параметры или задав им недопустимые значения.
• Операционная среда не сможет предоставить программе необходи%
мый сервер.
• Внешние библиотеки окажутся некорректными и не выполнят те
контракты по интерфейсам, на которые вы полагались.
9. Стремитесь к ясности, а не к краткости
Когда встает выбор между кратким (но непонятным) и ясным (но скуч%
ным) кодом, делайте его в пользу того кода, смысл которого понятен,
даже если он менее элегантен. Например, сложные арифметические
выражения разбивайте на последовательность отдельных операторов,
логика которых понятнее.
10. Не позволяйте никому лезть туда, где ему нечего делать
• В объектно%ориентированных языках доступ к внутренним данным
класса запрещается путем объявления его закрытым. В C++ можно
воспользоваться идиомой Чеширского кота (или pimpl) – стандарт%
ным приемом, употребляемым для выведения внутренней структу%
ры класса из его открытого файла заголовка. (Meyers 97) 
• В процедурных языках также можно воспользоваться идеями объ%
ектно%ориентированной упаковки, заключив закрытые данные внут%
ри непрозрачных типов и обеспечив корректные операции над ними. 
• Дайте всем переменным минимально необходимую область видимо%
сти; не делайте их глобальными, если в этом нет необходимости. Ес%
ли их можно сделать локальными для функции, не объявляйте их
на уровне файла. Если их можно сделать локальными для цикла, не
объявляйте их на уровне функции.
11. Включайте вывод всех предупреждений при компиляции
Если ваш код изобилует опасными конструкциями, такие предупреж%
дения могут занять многие страницы. К сожалению, по этой причине
очень часто отключают вывод предупреждений компилятором или
просто не обращают на них внимания. Так поступать не следует.
Всегда включайте вывод предупреждений компилятором, и если ваш
код генерирует предупреждения, немедленно исправьте его, чтобы та%
ких сообщений больше не было. Нельзя успокаиваться, пока компиля%
ция не станет проходить гладко при включенном выводе предупрежде%
ний. Они существуют не зря. Даже когда вам кажется, что какое%то
предупреждение несущественно, добейтесь его исчезновения, потому
что в один прекрасный день из%за него вы не заметите того предупреж%
дения, которое окажется действительно важным.
12. Пользуйтесь средствами статического анализа
Предупреждения компилятора представляют собой результат частич%
ного статического анализа кода – контроля кода, проводимого перед
запуском программы.
13. Применяйте безопасные структуры данных
Вероятно, самым распространенным видом уязвимостей в программах
является переполнение буфера. Оно возникает из%за небрежного при%
менения структур данных фиксированного размера. Если ваш код за%
писывает данные в буфер, не проверив предварительно его размер, то
возникает опасность записи за концом буфера.
14. Проверяйте все возвращаемые значения
Если функция возвращает значение, то делает это не зря. Проверяйте
возвращаемое значение. Если это код ошибки, нужно ее обработать.
Не допускайте появления в программе незамеченных ошибок; в итоге
поведение программы может стать непредсказуемым.
15. Аккуратно обращайтесь с памятью 
(и другими ценными ресурсами)
Будьте скрупулезны и освобождайте все ресурсы, которые захватывае%
те во время выполнения. Чаще всего имеется в виду оперативная па%
мять, но это не единственный ресурс. К другим видам ценных ресурсов,
которые нужно беречь, относятся файлы и блокировки потоков. Рас%
поряжайтесь своим добром экономно.
16. Инициализируйте все переменные там, где вы их объявили
Это проблема ясности. Смысл каждой переменной становится ясен, ес%
ли вы инициализируете ее. Опасно полагаться на эмпирические пра%
вила типа: «Раз я ее не инициализировал, значит, ее начальное значе#
ние мне неважно». Код со временем развивается. Отсутствие началь%
ного значения на каком%то этапе может превратиться в проблему.
17. Объявляйте переменные как можно позже
Благодаря этому переменная будет располагаться ближе к месту сво%
его использования и не станет мешаться в других частях кода. Кроме
того, понятнее станет код, в котором участвует эта переменная. Вам не
придется рыскать, выясняя тип и значение переменной: расположен%
ное рядом объявление сделает их очевидными.
18. Пользуйтесь стандартными средствами языка
C и C++ в этом отношении представляют собой кошмар. Их специфи%
кации существуют во многих вариантах, а поведение в наименее ясных
ситуациях не определено и оставлено на усмотрение конкретных реа%
лизаций. На сегодняшний день существует множество компиляторов,
обладающих тонкими различиями. В целом они совместимы между со%
бой, но оставляют вам достаточно возможностей свернуть себе шею.
19. Пользуйтесь хорошими средствами регистрации 
диагностических сообщений
Когда пишут новый код, то часто включают в него много операторов
вывода диагностики, чтобы разобраться в происходящем в программе.
Следует ли удалить их в конце работы? Сохранив их, вы облегчите
себе жизнь в будущем, если придется вернуться к этому коду, особен%
но если можно управлять выводом диагностики.
20. Выполняйте приведение типов с осторожностью
Большинство языков позволяет приводить (преобразовывать) данные
из одного типа в другой. Эта операция не всегда проходит успешно. Ес%
ли вы попытаетесь преобразовать 64%разрядное целое в меньший, 8%раз%
рядный тип, то что произойдет с 56 оставшимися битами? Среда вы%
полнения может неожиданно сгенерировать исключительную ситуа%
цию, а может исказить ваши данные, ничего при этом не сообщив.
Программисты часто не задумываются над такого рода вещами, а по%
тому их программы ведут себя неожиданным образом.
21. Подробности
Определяйте поведение по умолчанию
В большинстве языков есть оператор switch (переключатель), позво%
ляющий любую неожиданность обработать в группе default (по
умолчанию). Если попадание в default является ошибкой, явно от%
разите это в коде. Если ошибки нет, также отразите это в коде, и то%
гда сопровождающему код программисту станет все ясно.
Аналогично, если вы пишете оператор if без предложения else, за%
думайтесь, не следует ли обрабатывать логический случай по умол%
чанию.
Пользуйтесь идиомами языка
Следуя этому простому совету, вы гарантируете, что ваш код будет
понятен читающим его. Они реже будут ошибаться.
Проверяйте числовые результаты
Даже самые простые вычисления могут приводить к переполнению
или потере точности. Будьте настороже. Спецификации языков и ба%
зовые библиотеки предоставляют механизмы для определения до%
пустимых значений стандартных типов данных – воспользуйтесь
ими. Вы должны знать, какие числовые типы существуют и для ка%
ких целей их лучше применять.
Проверяйте допустимость каждого вычисления. Например, следи%
те за тем, чтобы ваши величины не приводили к делению на ноль.
Соблюдайте защищенность констант
Особенно это облегчает жизнь при программировании на C/C++. Ста%
райтесь объявлять как const все, что только можно. Этим достигают%
ся две цели: квалификаторы const способствуют документированию
кода и позволяют компилятору обнаруживать глупые ошибки. Он не
позволит вам изменить данные, модификация которых запрещена.
22. Ограничения
. Есть несколько вариантов реакции программы:
• Сделать вид, что ничего не случилось, и надеяться на лучшее.
• Оштрафовать на месте и разрешить дальнейшее движение (напри%
мер, напечатать диагностическое предупреждение или записать его
в журнал).
• Сразу арестовать; запретить двигаться дальше (например, прервать
выполнение программы контролируемым или неконтролируемым
образом).
Существует несколько разных сценариев использования ограничений:
Входные условия
Эти условия должны быть выполнены до входа в раздел кода. Если
входное условие не выполнено, это означает, что в коде клиента
есть ошибка.
Выходные условия
Эти условия должны быть выполнены после выхода из блока кода.
Если выходное условие не выполнено, это означает, что в коде по%
ставщика есть ошибка.
Инварианты
Эти условия должны быть выполнены при достижении в ходе вы%
полнения программы определенной точки, например между прохо%
дами цикла, при вызове методов и т. п. Невыполнение инварианта
означает, что в логике программы есть ошибка.
Операторы контроля
Это любое другое утверждение относительно состояния программы
в данный момент.
23. Какие ограничения налагать
Есть несколько проблем, которые можно решать с помощью ограниче%
ний. Например, можно делать следующее:
• Проверять, чтобы все обращения к массивам не выходили за их гра%
ницы.
• Контролировать неравенство нулю указателей перед их разымено%
ванием.
• Проверять допустимость параметров функций.
• Контролировать результаты функций, прежде чем их возвращать.
• Проверять состояние объекта перед операциями с ним.
• Защищать те участки кода, где должны быть комментарии. Они не
должны получать управление.
24. Снятие ограничений
Такого рода проверка ограничений обычно требуется только на этапах
разработки и отладки программы. После того как мы воспользовались
ограничениями, чтобы убедить себя (возможно, ошибочно) в правиль%
ности логики программы, следовало бы убрать их, чтобы готовая про%
грамма не делала лишней работы.
25. Резюме
Необходимо писать не просто корректный, но хороший код. Для этого
нужно документировать все сделанные предположения. В результате
код станет легче сопровождать и в нем окажется меньше места для
ошибок. Защитное программирование ориентировано на то, чтобы быть
готовым к худшему, что может случиться. Данная технология препят%
ствует превращению случайных огрехов в трудноуловимые ошибки.
2 глава
