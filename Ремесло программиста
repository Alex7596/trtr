1 глава
Держим оборону
1. На пути к хорошему коду
Есть огромная разница между кодом, который на первый взгляд работа%
ет, правильным кодом и хорошим кодом. М. Э. Джексон (M. A. Jackson)
писал: «Всякий мудрый программист должен понимать, что есть раз%
ница между тем, чтобы заставить программу работать, и тем, чтобы за%
ставить ее делать это правильно». (Jackson 75) И вот в чем эта разница:
• Легко написать код, который почти всегда работает. Вводишь
в программу обычные данные и получаешь обычные результаты.
Но стоит подать на вход нечто необычное, и все может рухнуть.
• Правильный код не рухнет. Для любого набора входных данных ре%
зультат будет корректен. Однако обычно количество всевозможных
комбинаций входных данных оказывается невероятно большим,
и все их трудно протестировать.
• Однако не всякий правильный код оказывается хорошим – напри%
мер, его логику трудно проследить, код непонятен, его практически
невозможно сопровождать.
2. Готовьтесь к худшему
Предположения служат причиной появления кода с ошибками. Очень
легко предположить следующее:
• Функцию никогда не станут вызывать таким способом. Ей всегда
будут передаваться только допустимые параметры.
• Этот фрагмент кода всегда будет работать, он никогда не сгенериру%
ет ошибку.
• Никто не станет пытаться обратиться к этой переменной, если
я напишу в документации, что она предназначена только для
внутреннего употребления.
3. Что такое защитное программирование
Как следует из названия, защитное программирование – это тщатель%
ное, осторожное программирование. Чтобы построить надежную про%
грамму, мы должны спроектировать каждую компоненту системы так,
чтобы она была как можно лучше защищена. Мы расправимся с непи%
саными допущениями, сделав для них явные проверки в коде. Таким
способом мы попытаемся предотвратить или хотя бы обнаружить такое
обращение к нашему коду, которое вызывает некорректное поведение.
Защитное программирование позволяет обнаружить мелкие проблемы
на ранней стадии, не дожидаясь момента, когда они приведут к серьез%
ным катастрофам. Сплошь и рядом можно столкнуться с тем, как
«профессиональные» разработчики спешат написать код, не дав себе
труда задуматься.
4. Этот страшный, ужасный мир
Защитное программирование повышает безопасность программ, пред%
охраняя от такого рода умышленного злоупотребления. Взломщики и
создатели вирусов не упускают случая воспользоваться неаккуратно
написанным кодом, чтобы получить контроль над приложением и реа%
лизовать свои зловредные планы. Это серьезная угроза в современном
мире программных разработок, которая приводит к огромному ущер%
бу, наносимому продуктивности, финансам и конфиденциальности.
5. Технологии защитного программирования
Защитное программирование предполагает соблюдение ряда разум%
ных правил. Обычно, когда заходит речь о защитном программирова%
нии, людям приходит в голову использовать операторы контроля,
и это правильно. Мы поговорим о них позже. Но существует также мас%
са простых приемов программирования, которые неизмеримо повысят
надежность вашего кода.
6. Выберите хороший стиль кодирования 
и пользуйтесь крепкой архитектурой
Значительной части ошибок можно избежать, придерживаясь доброт%
ного стиля кодирования. Это правило согласуется с остальными глава%
ми данной части. Такие простые вещи, как выбор осмысленных имен
переменных и разумная расстановка скобок, делают код понятнее
и уменьшают шансы пропустить ошибку.
7. Пишите код без спешки
Сплошь и рядом программы пишут сломя голову. Программист быстренько ляпает функцию, пропускает ее через компилятор для проверки синтаксиса, запускает, чтобы убедиться в ее работоспособности,
и переходит к очередной задаче. Такой подход чреват опасными по%
следствиями.
8. Не верьте никому
• Обычный пользователь случайно введет в программу неверные
данные или воспользуется ею некорректно.
• Злоумышленник сознательно попытается заставить программу ве%
сти себя некорректно.
• Клиентский код вызовет вашу функцию, неправильно передав ей
параметры или задав им недопустимые значения.
• Операционная среда не сможет предоставить программе необходи%
мый сервер.
• Внешние библиотеки окажутся некорректными и не выполнят те
контракты по интерфейсам, на которые вы полагались.
9. Стремитесь к ясности, а не к краткости
Когда встает выбор между кратким (но непонятным) и ясным (но скуч%
ным) кодом, делайте его в пользу того кода, смысл которого понятен,
даже если он менее элегантен. Например, сложные арифметические
выражения разбивайте на последовательность отдельных операторов,
логика которых понятнее.
10. Не позволяйте никому лезть туда, где ему нечего делать
• В объектно%ориентированных языках доступ к внутренним данным
класса запрещается путем объявления его закрытым. В C++ можно
воспользоваться идиомой Чеширского кота (или pimpl) – стандарт%
ным приемом, употребляемым для выведения внутренней структу%
ры класса из его открытого файла заголовка. (Meyers 97) 
• В процедурных языках также можно воспользоваться идеями объ%
ектно%ориентированной упаковки, заключив закрытые данные внут%
ри непрозрачных типов и обеспечив корректные операции над ними. 
• Дайте всем переменным минимально необходимую область видимо%
сти; не делайте их глобальными, если в этом нет необходимости. Ес%
ли их можно сделать локальными для функции, не объявляйте их
на уровне файла. Если их можно сделать локальными для цикла, не
объявляйте их на уровне функции.
11. Включайте вывод всех предупреждений при компиляции
Если ваш код изобилует опасными конструкциями, такие предупреж%
дения могут занять многие страницы. К сожалению, по этой причине
очень часто отключают вывод предупреждений компилятором или
просто не обращают на них внимания. Так поступать не следует.
Всегда включайте вывод предупреждений компилятором, и если ваш
код генерирует предупреждения, немедленно исправьте его, чтобы та%
ких сообщений больше не было. Нельзя успокаиваться, пока компиля%
ция не станет проходить гладко при включенном выводе предупрежде%
ний. Они существуют не зря. Даже когда вам кажется, что какое%то
предупреждение несущественно, добейтесь его исчезновения, потому
что в один прекрасный день из%за него вы не заметите того предупреж%
дения, которое окажется действительно важным.
12. Пользуйтесь средствами статического анализа
Предупреждения компилятора представляют собой результат частич%
ного статического анализа кода – контроля кода, проводимого перед
запуском программы.
13. Применяйте безопасные структуры данных
Вероятно, самым распространенным видом уязвимостей в программах
является переполнение буфера. Оно возникает из%за небрежного при%
менения структур данных фиксированного размера. Если ваш код за%
писывает данные в буфер, не проверив предварительно его размер, то
возникает опасность записи за концом буфера.
14. Проверяйте все возвращаемые значения
Если функция возвращает значение, то делает это не зря. Проверяйте
возвращаемое значение. Если это код ошибки, нужно ее обработать.
Не допускайте появления в программе незамеченных ошибок; в итоге
поведение программы может стать непредсказуемым.
15. Аккуратно обращайтесь с памятью 
(и другими ценными ресурсами)
Будьте скрупулезны и освобождайте все ресурсы, которые захватывае%
те во время выполнения. Чаще всего имеется в виду оперативная па%
мять, но это не единственный ресурс. К другим видам ценных ресурсов,
которые нужно беречь, относятся файлы и блокировки потоков. Рас%
поряжайтесь своим добром экономно.
16. Инициализируйте все переменные там, где вы их объявили
Это проблема ясности. Смысл каждой переменной становится ясен, ес%
ли вы инициализируете ее. Опасно полагаться на эмпирические пра%
вила типа: «Раз я ее не инициализировал, значит, ее начальное значе#
ние мне неважно». Код со временем развивается. Отсутствие началь%
ного значения на каком%то этапе может превратиться в проблему.
17. Объявляйте переменные как можно позже
Благодаря этому переменная будет располагаться ближе к месту сво%
его использования и не станет мешаться в других частях кода. Кроме
того, понятнее станет код, в котором участвует эта переменная. Вам не
придется рыскать, выясняя тип и значение переменной: расположен%
ное рядом объявление сделает их очевидными.
18. Пользуйтесь стандартными средствами языка
C и C++ в этом отношении представляют собой кошмар. Их специфи%
кации существуют во многих вариантах, а поведение в наименее ясных
ситуациях не определено и оставлено на усмотрение конкретных реа%
лизаций. На сегодняшний день существует множество компиляторов,
обладающих тонкими различиями. В целом они совместимы между со%
бой, но оставляют вам достаточно возможностей свернуть себе шею.
19. Пользуйтесь хорошими средствами регистрации 
диагностических сообщений
Когда пишут новый код, то часто включают в него много операторов
вывода диагностики, чтобы разобраться в происходящем в программе.
Следует ли удалить их в конце работы? Сохранив их, вы облегчите
себе жизнь в будущем, если придется вернуться к этому коду, особен%
но если можно управлять выводом диагностики.
20. Выполняйте приведение типов с осторожностью
Большинство языков позволяет приводить (преобразовывать) данные
из одного типа в другой. Эта операция не всегда проходит успешно. Ес%
ли вы попытаетесь преобразовать 64%разрядное целое в меньший, 8%раз%
рядный тип, то что произойдет с 56 оставшимися битами? Среда вы%
полнения может неожиданно сгенерировать исключительную ситуа%
цию, а может исказить ваши данные, ничего при этом не сообщив.
Программисты часто не задумываются над такого рода вещами, а по%
тому их программы ведут себя неожиданным образом.
21. Подробности
Определяйте поведение по умолчанию
В большинстве языков есть оператор switch (переключатель), позво%
ляющий любую неожиданность обработать в группе default (по
умолчанию). Если попадание в default является ошибкой, явно от%
разите это в коде. Если ошибки нет, также отразите это в коде, и то%
гда сопровождающему код программисту станет все ясно.
Аналогично, если вы пишете оператор if без предложения else, за%
думайтесь, не следует ли обрабатывать логический случай по умол%
чанию.
Пользуйтесь идиомами языка
Следуя этому простому совету, вы гарантируете, что ваш код будет
понятен читающим его. Они реже будут ошибаться.
Проверяйте числовые результаты
Даже самые простые вычисления могут приводить к переполнению
или потере точности. Будьте настороже. Спецификации языков и ба%
зовые библиотеки предоставляют механизмы для определения до%
пустимых значений стандартных типов данных – воспользуйтесь
ими. Вы должны знать, какие числовые типы существуют и для ка%
ких целей их лучше применять.
Проверяйте допустимость каждого вычисления. Например, следи%
те за тем, чтобы ваши величины не приводили к делению на ноль.
Соблюдайте защищенность констант
Особенно это облегчает жизнь при программировании на C/C++. Ста%
райтесь объявлять как const все, что только можно. Этим достигают%
ся две цели: квалификаторы const способствуют документированию
кода и позволяют компилятору обнаруживать глупые ошибки. Он не
позволит вам изменить данные, модификация которых запрещена.
22. Ограничения
. Есть несколько вариантов реакции программы:
• Сделать вид, что ничего не случилось, и надеяться на лучшее.
• Оштрафовать на месте и разрешить дальнейшее движение (напри%
мер, напечатать диагностическое предупреждение или записать его
в журнал).
• Сразу арестовать; запретить двигаться дальше (например, прервать
выполнение программы контролируемым или неконтролируемым
образом).
Существует несколько разных сценариев использования ограничений:
Входные условия
Эти условия должны быть выполнены до входа в раздел кода. Если
входное условие не выполнено, это означает, что в коде клиента
есть ошибка.
Выходные условия
Эти условия должны быть выполнены после выхода из блока кода.
Если выходное условие не выполнено, это означает, что в коде по%
ставщика есть ошибка.
Инварианты
Эти условия должны быть выполнены при достижении в ходе вы%
полнения программы определенной точки, например между прохо%
дами цикла, при вызове методов и т. п. Невыполнение инварианта
означает, что в логике программы есть ошибка.
Операторы контроля
Это любое другое утверждение относительно состояния программы
в данный момент.
23. Какие ограничения налагать
Есть несколько проблем, которые можно решать с помощью ограниче%
ний. Например, можно делать следующее:
• Проверять, чтобы все обращения к массивам не выходили за их гра%
ницы.
• Контролировать неравенство нулю указателей перед их разымено%
ванием.
• Проверять допустимость параметров функций.
• Контролировать результаты функций, прежде чем их возвращать.
• Проверять состояние объекта перед операциями с ним.
• Защищать те участки кода, где должны быть комментарии. Они не
должны получать управление.
24. Снятие ограничений
Такого рода проверка ограничений обычно требуется только на этапах
разработки и отладки программы. После того как мы воспользовались
ограничениями, чтобы убедить себя (возможно, ошибочно) в правиль%
ности логики программы, следовало бы убрать их, чтобы готовая про%
грамма не делала лишней работы.
25. Резюме
Необходимо писать не просто корректный, но хороший код. Для этого
нужно документировать все сделанные предположения. В результате
код станет легче сопровождать и в нем окажется меньше места для
ошибок. Защитное программирование ориентировано на то, чтобы быть
готовым к худшему, что может случиться. Данная технология препят%
ствует превращению случайных огрехов в трудноуловимые ошибки.
2 глава
Тонкий расчет
1. Да в чем проблема?
Расположение и представление кода оказываются предметом разно%
гласий в большинстве современных языков программирования. Про%
извольное форматирование, позволяющее выразить свою художест%
венную индивидуальность, вошло в моду в начале 1960%х годов с появ%
лением Алгола: существовавшие к тому времени версии Fortran до%
пускали меньше свободы в формате. В последующем лишь очень
немногие языки отошли от такого подхода к свободе форматирования.
2. Знайте своих клиентов
Чтобы написать эффективный исходный код, необходимо понимать,
кто его будет читать. Если придется кого%то поставить в трудное поло%
жение, выясните, перед кем потом извиняться. В действительности,
есть три круга адресатов вашего кода:
Вы сами
У меня такой плохой почерк, что иногда мне самому трудно его ра%
зобрать. Это практически невозможно, если я не ставлю себе задачу
писать разборчиво. То же самое происходит и с кодом. Созданное ва%
ми должно быть понятно не только сразу после написания, но и по
прошествии лет. Кто мог подумать, что придется вернуться к (отно%
сительно) архаичному коду на COBOL, чтобы исправить в нем
ошибки, связанные с Y2K?
Компилятор
Компилятору все равно, как выглядит ваш код, – лишь бы в нем не
было синтаксических ошибок. Ему абсолютно безразлично, какую
задачу этот код решает. Можно подробно описать в комментариях,
что должна делать функция, но компилятор никогда не сообщит вам,
действительно ли она выполняет то, что сказано в комментариях.
Если код корректен, среда разработки будет вполне удовлетворена.
Прочие лица 
Это самая важная аудитория, интересы которой часто меньше всего
учитываются. 
Вам кажется, что хотя вы работаете в составе команды, никто нико%
гда не станет смотреть ваш код. Это ошибочное мнение.
Вы пишете какой%то код для себя дома. Стоит ли заботиться о его кра%
соте? Если «да», то в чем польза? В выработке качеств, которые дела%
ют вас профессионалом. У вас появляется прекрасная возможность
продемонстрировать настоящую дисциплину в проекте, когда никто
не оказывает на вас давления. Это возможность выработать хорошие
манеры. Если вы не справитесь с задачей в таких условиях, то неуди%
вительно, что у вас не хватит дисциплины в реальных проектах. 
3. Что такое хорошее представление?
Расположение кода должно передавать его смысл, а не скрывать.
Я предлагаю следующие критерии качества стиля представления кода.
Единообразие
Принципы отступов в коде должны быть одинаковы во всех частях
проекта. Не меняйте стиль в середине пути. Это не только выглядит
непрофессионально, но и может ввести в заблуждение, создавая
впечатление отсутствия связи между файлами с исходным кодом.
Отдельные правила представления должны быть внутренне непроти%
воречивыми. Расположение фигурных и квадратных скобок и т. п.
в различных ситуациях должно соответствовать единым правилам.
Количество пробелов в отступах должно быть всегда одинаковым.
Керниган и Ричи, основоположники C, подчеркивают важность
правильных отступов и затем говорят: «Положение скобок менее
важно, хотя люди склонны проявлять фанатизм в таких вопросах.
Мы выбрали один из нескольких популярных стилей. Выберите тот
стиль, который вам больше подходит, и точно ему следуйте». (Ker%
nighan Ritchie 88)
Стандартность
Разумно принять какой%нибудь из господствующих ныне стилей,
а не изобретать собственные правила отступа. Так будет проще для
тех, кто станет читать ваш код. И меньше шансов, что ваш стиль
вызовет у них отвращение.
Краткость
Можете ли вы кратко описать свою стратегию отступов? Подумайте
над этим. Если вы делаете нечто, пока не произойдет то#то и то#
то, а тогда вы будете делать это, если выполняется X; в противном
случае вы станете делать нечто другое в зависимости от…
Кому%то может потребоваться дополнить написанный вами код, и де%
лать это ему следует, придерживаясь того же стиля. Если его трудно
ухватить, можно ли считать такой стиль представления удачным?
4. Размещение скобок
Для иллюстрации влияния, которое представление оказывает на ис%
ходный код, и компромиссов, на которые приходится идти при выборе
стиля, разберем конкретный случай, связанный с важной проблемой
расположения кода C. Рассматривая варианты, возникающие в этой
одной простой области, мы продемонстрируем важность представле%
ния и степень его влияния на код.
5. Скобки в стиле K&R
Стиль K&R относится к старейшим, будучи предложенным основопо%
ложниками языка C, Керниганом и Ричи, в книге «Язык программи%
рования C» (Kernighan Ritchie 88). По этой причине его часто считают
исходным и лучшим. На него повлияла необходимость отобразить как
можно больше информации на маленьком экране. Пожалуй, это пре%
валирующий стиль для кода Java.
6. Расширенный стиль скобок
Более свободное расположение кода достигается в расширенном (ex#
dented) стиле, называемом также стилем Олмана. Лично мне он нра%
вится больше прочих.
7. Стиль Уайтсмита (с отступами)
Стиль с отступами менее распространен, хотя и встречается. Фигур%
ные скобки при этом имеют тот же отступ, что и код. Он получил на%
звание стиля Уайтсмита, поскольку применялся в примерах для
Whitesmiths C – раннего компилятора с языка С.
8. Другие стили скобок
Существуют и другие стили. Например, стиль GNU занимает промежу%
точное положение между расширенным стилем и стилем с отступами:
скобки располагаются посередине каждого уровня отступа. Есть и гиб%
ридные стили: стиль кода ядра Linux наполовину представляет K&R,
наполовину – стиль Олмана. Большинство программирующих на C#
тоже комбинирует стили расположения.
9. Единственно верный стиль
Поняв, что такое правильный стиль кодирования, на что он влияет
и почему необходим, нужно выбрать для себя что%то подходящее. Вот
тут и начинается столкновение. Последовательности одного религиоз%
ного течения в представлении ведут борьбу с проповедниками другого,
порождая гражданские войны между программистами. Но настоящий
мастер не ввязывается в эти мелкие дрязги, предпочитая взвешенный
подход.
10. Внутрифирменные стили 
(и когда их придерживаться)
Важность и полезность внутрифирменных стилей обусловлена рядом
причин. Когда все танцуют под одну дудку, исходный код оказывается
полностью единообразным и однородным. Что в этом хорошего? Улуч%
шается качество кода и растет надежность разработки программного
обеспечения. И вот почему:
• Любой код, выходящий за пределы организации, имеет аккуратное
представление и согласованность, создавая впечатление хорошей
продуманности. Наличие в одном проекте разнородных стилей соз%
дает впечатление неряшливости и непрофессионализма.
• Компания может быть уверена в том, что программы пишутся со%
гласно единому стандарту, включающему в себя определенные
идиомы и методологии. Это не гарантирует получение хорошего ко%
да, но дает некоторую защиту от появления плохого кода.
• Компенсируются недостатки инструментария: по разному настро%
енные IDE будут вступать в конфликт между собой, разрывая код
на части и досаждая форматированием. Стандарт создает ровную
почву (и общего врага для всех программистов).
• Привлекательна возможность сразу оценить состояние кода, напи%
санного коллегами, и быстро сделать необходимые изменения при
сопровождении. Меньше времени тратится на чтение, а значит, бе%
регутся финансовые ресурсы компании.
• Поскольку программисты перестанут непрерывно заново формати%
ровать код в соответствии со своими эстетическими пристрастия%
ми, система управления версиями станет намного эффективнее. Ес%
ли один программист будет переформатировать код второго, чтобы
привести его к «своему» стилю, это отразится на работе утилит,
сравнивающих версии. Многие из них действуют довольно грубо
и покажут массу несущественных различий в расстановке пробель%
ных символов и скобок.
11. Установка стандарта
Сложность задачи зависит от особенностей членов вашего коллектива:
• Сколько всего программистов
• Как каждый в отдельности пишет код
• Насколько схожи между собой их стили программирования
• Заинтересованы ли они в наличии стандарта
• Готовы ли они к тому, чтобы изменить свой стиль
12. Религиозные войны?
Вести религиозные войны по поводу форматирования кода – пустая
трата времени; есть гораздо более важные проблемы, заслуживающие
вашего внимания. Но будьте осторожны: формат кода – не единствен%
ное больное место у программистов. Помимо него существуют выбор
редактора, компилятора, методологии, Настоящего языка1 и т. д.
13. Резюме
Представление – одна из главных характеристик, отличающих хоро%
ший код от плохого. Программист может многое узнать по внешнему
виду кода, поэтому стоит позаботиться о его надлежащем форматиро%
вании. Важно уметь толково расположить код в соответствии с прави%
лами существующего в фирме стандарта кодирования, обеспечив его
максимальную понятность.
3 глава
Что в имени тебе моем?
1. Зачем нужны хорошие имена?
Нужно тщательно выбирать имена для своих объектов. Ведь исходный
код должен быть понятен. Имя создает путь к пониманию, контролю
и овладению. Если правильно выбрать имя, по нему можно понять на#
значение объекта. 
2. Каким объектам мы даем имена?
Задумаемся как программисты над тем, каким объектам мы даем име%
на и какие имена мы им даем. Сначала о том, какие конструкции ча%
ще всего получают от нас имена, когда мы пишем код:
• Переменные
• Функции
• Типы (классы, перечисления, структуры, определения типов)
• Имена пространств C++ и пакетов Java
• Макросы
• Файлы с исходным текстом
3. Игра в названия
Какое назначить имя? Техника создания любого имени зависит от
стандарта кодирования, которого вы придерживаетесь. Однако хотя
стандарт и определяет некоторые правила составления имен, он не бы%
вает настолько конкретным, чтобы определить правильное имя любо%
го элемента, входящего в программу. 
